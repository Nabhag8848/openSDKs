/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  '/v1/workspaces/create': {
    /** Creates a workspace */
    post: operations['createWorkspace']
  }
  '/v1/workspaces/create_if_not_exist': {
    /** Creates a workspace with an explicit workspace ID. This should be use in acceptance tests only. */
    post: operations['createWorkspaceIfNotExist']
  }
  '/v1/workspaces/delete': {
    /** Deletes a workspace */
    post: operations['deleteWorkspace']
  }
  '/v1/workspaces/list': {
    /** List all workspaces registered in the current Airbyte deployment */
    post: operations['listWorkspaces']
  }
  '/v1/workspaces/list_all_paginated': {
    /** List all workspaces registered in the current Airbyte deployment. This function also supports searching by keyword and pagination. */
    post: operations['listAllWorkspacesPaginated']
  }
  '/v1/workspaces/list_paginated': {
    /** List workspaces by given workspace IDs registered in the current Airbyte deployment. This function also supports pagination. */
    post: operations['listWorkspacesPaginated']
  }
  '/v1/workspaces/list_by_organization_id': {
    /** List workspaces under the given org id. This function also supports searching by keyword and pagination. */
    post: operations['listWorkspacesInOrganization']
  }
  '/v1/workspaces/list_by_user_id': {
    /** List workspaces by a given user id. The function also supports searching by keyword and pagination. */
    post: operations['listWorkspacesByUser']
  }
  '/v1/workspaces/get': {
    /** Find workspace by ID */
    post: operations['getWorkspace']
  }
  '/v1/workspaces/get_by_slug': {
    /** Find workspace by slug */
    post: operations['getWorkspaceBySlug']
  }
  '/v1/workspaces/get_by_connection_id': {
    /** Find workspace by connection id */
    post: operations['getWorkspaceByConnectionId']
  }
  '/v1/workspaces/get_by_connection_id_with_tombstone': {
    /** Find workspace by connection id including the tombstone ones */
    post: operations['getWorkspaceByConnectionIdWithTombstone']
  }
  '/v1/workspaces/get_organization_info': {
    /** Retrieve a workspace's basic organization info that is accessible for all workspace members, regardless of organization membership. */
    post: operations['getOrganizationInfo']
  }
  '/v1/workspaces/update': {
    /** Update workspace state */
    post: operations['updateWorkspace']
  }
  '/v1/workspaces/update_name': {
    /** Update workspace name */
    post: operations['updateWorkspaceName']
  }
  '/v1/workspaces/update_organization': {
    /** Update workspace organization */
    post: operations['updateWorkspaceOrganization']
  }
  '/v1/workspaces/tag_feedback_status_as_done': {
    /** Update workspace feedback state */
    post: operations['updateWorkspaceFeedback']
  }
  '/v1/notifications/try': {
    /** Try sending a notifications; to be deprecated */
    post: operations['tryNotificationConfig']
  }
  '/v1/notifications/try_webhook': {
    /** Try sending a notifications to webhook */
    post: operations['tryNotificationWebhookConfig']
  }
  '/v1/source_definitions/update': {
    /** Update a sourceDefinition */
    post: operations['updateSourceDefinition']
  }
  '/v1/source_definitions/list': {
    /** List all the sourceDefinitions the current Airbyte deployment is configured to use */
    post: operations['listSourceDefinitions']
  }
  '/v1/source_definitions/list_latest': {
    /**
     * List the latest sourceDefinitions Airbyte supports
     * @description Guaranteed to retrieve the latest information on supported sources.
     */
    post: operations['listLatestSourceDefinitions']
  }
  '/v1/source_definitions/get': {
    /** Get source */
    post: operations['getSourceDefinition']
  }
  '/v1/source_definitions/delete': {
    /** Delete a source definition */
    post: operations['deleteSourceDefinition']
  }
  '/v1/source_definitions/list_private': {
    /** List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
    post: operations['listPrivateSourceDefinitions']
  }
  '/v1/source_definitions/list_for_workspace': {
    /** List all the sourceDefinitions the given workspace is configured to use */
    post: operations['listSourceDefinitionsForWorkspace']
  }
  '/v1/source_definitions/create_custom': {
    /** Creates a custom sourceDefinition for the given workspace or organization */
    post: operations['createCustomSourceDefinition']
  }
  '/v1/source_definitions/get_for_workspace': {
    /** Get a sourceDefinition that is configured for the given workspace */
    post: operations['getSourceDefinitionForWorkspace']
  }
  '/v1/source_definitions/get_for_scope': {
    /** Get a sourceDefinition that is configured for the given workspace or organization */
    post: operations['getSourceDefinitionForScope']
  }
  '/v1/source_definitions/grant_definition': {
    /** grant a private, non-custom sourceDefinition to a given workspace or organization */
    post: operations['grantSourceDefinition']
  }
  '/v1/source_definitions/revoke_definition': {
    /** revoke a grant to a private, non-custom sourceDefinition from a given workspace or organization */
    post: operations['revokeSourceDefinition']
  }
  '/v1/actor_definition_versions/get_for_source': {
    /** Get actor definition version for a source. */
    post: operations['getActorDefinitionVersionForSourceId']
  }
  '/v1/source_definition_specifications/get': {
    /** Get specification for a SourceDefinition. */
    post: operations['getSourceDefinitionSpecification']
  }
  '/v1/source_definition_specifications/get_for_source': {
    /** Get specification for a source. */
    post: operations['getSpecificationForSourceId']
  }
  '/v1/actor_definition_versions/resolve': {
    /** Resolve an actor definition version by version tag. */
    post: operations['resolveActorDefinitionVersionByTag']
  }
  '/v1/declarative_source_definitions/create_manifest': {
    /** Create a declarative manifest to be used by the specified source definition */
    post: operations['createDeclarativeSourceDefinitionManifest']
  }
  '/v1/declarative_source_definitions/update_active_manifest': {
    /** Update the declarative manifest version for a source */
    post: operations['updateDeclarativeManifestVersion']
  }
  '/v1/declarative_source_definitions/list_manifests': {
    /** List all available declarative manifest versions of a declarative source definition */
    post: operations['listDeclarativeManifests']
  }
  '/v1/connector_builder_projects/create': {
    /** Create new connector builder project */
    post: operations['createConnectorBuilderProject']
  }
  '/v1/connector_builder_projects/publish': {
    /** Publish a connector to the workspace */
    post: operations['publishConnectorBuilderProject']
  }
  '/v1/connector_builder_projects/update': {
    /** Update connector builder project */
    post: operations['updateConnectorBuilderProject']
  }
  '/v1/connector_builder_projects/delete': {
    /** Deletes connector builder project */
    post: operations['deleteConnectorBuilderProject']
  }
  '/v1/connector_builder_projects/list': {
    /** List connector builder projects for workspace */
    post: operations['listConnectorBuilderProjects']
  }
  '/v1/connector_builder_projects/get_with_manifest': {
    /** Get a connector builder project with draft manifest */
    post: operations['getConnectorBuilderProject']
  }
  '/v1/connector_builder_projects/update_testing_values': {
    /** Submit a set of testing values to persist for a connector builder project */
    post: operations['updateConnectorBuilderProjectTestingValues']
  }
  '/v1/connector_builder_projects/read_stream': {
    /** Reads the target stream of the connector builder project using the persisted testing values */
    post: operations['readConnectorBuilderProjectStream']
  }
  '/v1/connector_documentation/get': {
    /** Get the documentation for a connector */
    post: operations['getConnectorDocumentation']
  }
  '/v1/sources/create': {
    /** Create a source */
    post: operations['createSource']
  }
  '/v1/sources/update': {
    /** Update a source */
    post: operations['updateSource']
  }
  '/v1/sources/partial_update': {
    /** Partially update a source */
    post: operations['partialUpdateSource']
  }
  '/v1/sources/upgrade_version': {
    /** Upgrade a source to the latest version */
    post: operations['upgradeSourceVersion']
  }
  '/v1/sources/list': {
    /**
     * List sources for workspace
     * @description List sources for workspace. Does not return deleted sources.
     */
    post: operations['listSourcesForWorkspace']
  }
  '/v1/sources/list_paginated': {
    /**
     * List sources for workspace
     * @description List sources for workspace. Does not return deleted sources. Paginated.
     */
    post: operations['listSourcesForWorkspacePaginated']
  }
  '/v1/sources/get': {
    /** Get source */
    post: operations['getSource']
  }
  '/v1/sources/most_recent_source_actor_catalog': {
    /** Get most recent ActorCatalog for source */
    post: operations['getMostRecentSourceActorCatalog']
  }
  '/v1/sources/search': {
    /** Search sources */
    post: operations['searchSources']
  }
  '/v1/sources/clone': {
    /** Clone source */
    post: operations['cloneSource']
  }
  '/v1/sources/delete': {
    /** Delete a source */
    post: operations['deleteSource']
  }
  '/v1/sources/check_connection': {
    /** Check connection to the source */
    post: operations['checkConnectionToSource']
  }
  '/v1/sources/check_connection_for_update': {
    /** Check connection for a proposed update to a source */
    post: operations['checkConnectionToSourceForUpdate']
  }
  '/v1/sources/discover_schema': {
    /** Discover the schema catalog of the source */
    post: operations['discoverSchemaForSource']
  }
  '/v1/sources/apply_schema_changes': {
    /** Auto propagate the change on a catalog to a catalog saved in the DB. It will fetch all the connections linked to a source id and apply the provided diff to their catalog. */
    post: operations['applySchemaChangeForSource']
  }
  '/v1/sources/write_discover_catalog_result': {
    /** Should only called from worker, to write result from discover activity back to DB. */
    post: operations['writeDiscoverCatalogResult']
  }
  '/v1/destination_definitions/update': {
    /** Update destinationDefinition */
    post: operations['updateDestinationDefinition']
  }
  '/v1/destination_definitions/list': {
    /** List all the destinationDefinitions the current Airbyte deployment is configured to use */
    post: operations['listDestinationDefinitions']
  }
  '/v1/destination_definitions/list_latest': {
    /**
     * List the latest destinationDefinitions Airbyte supports
     * @description Guaranteed to retrieve the latest information on supported destinations.
     */
    post: operations['listLatestDestinationDefinitions']
  }
  '/v1/destination_definitions/get': {
    /** Get destinationDefinition */
    post: operations['getDestinationDefinition']
  }
  '/v1/destination_definitions/delete': {
    /** Delete a destination definition */
    post: operations['deleteDestinationDefinition']
  }
  '/v1/destination_definitions/list_private': {
    /** List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
    post: operations['listPrivateDestinationDefinitions']
  }
  '/v1/destination_definitions/list_for_workspace': {
    /** List all the destinationDefinitions the given workspace is configured to use */
    post: operations['listDestinationDefinitionsForWorkspace']
  }
  '/v1/destination_definitions/create_custom': {
    /** Creates a custom destinationDefinition for the given workspace */
    post: operations['createCustomDestinationDefinition']
  }
  '/v1/destination_definitions/get_for_workspace': {
    /** Get a destinationDefinition that is configured for the given workspace */
    post: operations['getDestinationDefinitionForWorkspace']
  }
  '/v1/destination_definitions/get_for_scope': {
    /** Get a destinationDefinition that is configured for the given scope */
    post: operations['getDestinationDefinitionForScope']
  }
  '/v1/destination_definitions/grant_definition': {
    /** grant a private, non-custom destinationDefinition to a given workspace or organization */
    post: operations['grantDestinationDefinition']
  }
  '/v1/destination_definitions/revoke_definition': {
    /** revoke a grant to a private, non-custom destinationDefinition from a given workspace or organization */
    post: operations['revokeDestinationDefinition']
  }
  '/v1/actor_definition_versions/get_for_destination': {
    /** Get actor definition version for a destination. */
    post: operations['getActorDefinitionVersionForDestinationId']
  }
  '/v1/destination_definition_specifications/get': {
    /** Get specification for a destinationDefinition */
    post: operations['getDestinationDefinitionSpecification']
  }
  '/v1/destination_definition_specifications/get_for_destination': {
    /** Get specification for a destination */
    post: operations['getSpecificationForDestinationId']
  }
  '/v1/destinations/create': {
    /** Create a destination */
    post: operations['createDestination']
  }
  '/v1/destinations/update': {
    /** Update a destination */
    post: operations['updateDestination']
  }
  '/v1/destinations/partial_update': {
    /** Update a destination partially */
    post: operations['partialUpdateDestination']
  }
  '/v1/destinations/upgrade_version': {
    /** Upgrade a destination to the latest version */
    post: operations['upgradeDestinationVersion']
  }
  '/v1/destinations/list': {
    /** List configured destinations for a workspace */
    post: operations['listDestinationsForWorkspace']
  }
  '/v1/destinations/list_paginated': {
    /** List configured destinations for a workspace. Pginated */
    post: operations['listDestinationsForWorkspacesPaginated']
  }
  '/v1/destinations/get': {
    /** Get configured destination */
    post: operations['getDestination']
  }
  '/v1/destinations/search': {
    /** Search destinations */
    post: operations['searchDestinations']
  }
  '/v1/destinations/check_connection': {
    /** Check connection to the destination */
    post: operations['checkConnectionToDestination']
  }
  '/v1/destinations/check_connection_for_update': {
    /** Check connection for a proposed update to a destination */
    post: operations['checkConnectionToDestinationForUpdate']
  }
  '/v1/destinations/delete': {
    /** Delete the destination */
    post: operations['deleteDestination']
  }
  '/v1/destinations/clone': {
    /** Clone destination */
    post: operations['cloneDestination']
  }
  '/v1/connections/create': {
    /** Create a connection between a source and a destination */
    post: operations['createConnection']
  }
  '/v1/connections/update': {
    /**
     * Update a connection
     * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
     * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
     * with the catalog from the request. This means that to modify a single stream, the entire new catalog
     * containing the updated stream needs to be sent.
     */
    post: operations['updateConnection']
  }
  '/v1/connections/list': {
    /**
     * Returns all connections for a workspace.
     * @description List connections for workspace. Does not return deleted connections.
     */
    post: operations['listConnectionsForWorkspace']
  }
  '/v1/connections/list_paginated': {
    /**
     * Returns all connections for a workspace. Paginated.
     * @description List connections for workspace. Does not return deleted connections. Paginated.
     */
    post: operations['listConnectionsForWorkspacesPaginated']
  }
  '/v1/connections/list_all': {
    /**
     * Returns all connections for a workspace, including deleted connections.
     * @description List connections for workspace, including deleted connections.
     */
    post: operations['listAllConnectionsForWorkspace']
  }
  '/v1/connections/status': {
    /** Get the status of multiple connections */
    post: operations['getConnectionStatuses']
  }
  '/v1/connections/sync_progress': {
    /** Get progress information of the current sync of a connection */
    post: operations['getConnectionSyncProgress']
  }
  '/v1/connections/history/uptime': {
    /** Get the uptime history of a connection */
    post: operations['getConnectionUptimeHistory']
  }
  '/v1/connections/history/data': {
    /** Get the data history of a connection */
    post: operations['getConnectionDataHistory']
  }
  '/v1/connections/stream_history': {
    /** Get the history of a connection */
    post: operations['getConnectionStreamHistory']
  }
  '/v1/connections/get': {
    /** Get a connection */
    post: operations['getConnection']
  }
  '/v1/connections/getForJob': {
    /** Get a connection for a given jobId */
    post: operations['getConnectionForJob']
  }
  '/v1/connections/list_by_actor_definition': {
    /** List all connections that use the provided actor definition */
    post: operations['listConnectionsByActorDefinition']
  }
  '/v1/connections/apply_schema_changes': {
    /** Auto propagate the change on a catalog to a catalog saved in the DB for the given connection. */
    post: operations['applySchemaChangeForConnection']
  }
  '/v1/state/get': {
    /** Fetch the current state for a connection. */
    post: operations['getState']
  }
  '/v1/state/create_or_update': {
    /** Create or update the state for a connection. */
    post: operations['createOrUpdateState']
  }
  '/v1/state/create_or_update_safe': {
    /** Create or update the state for a connection. Throws error if a sync is currently running when this is called. */
    post: operations['createOrUpdateStateSafe']
  }
  '/v1/connections/search': {
    /** Search connections */
    post: operations['searchConnections']
  }
  '/v1/connections/delete': {
    /** Delete a connection */
    post: operations['deleteConnection']
  }
  '/v1/connections/sync': {
    /** Trigger a manual sync of the connection */
    post: operations['syncConnection']
  }
  '/v1/connections/reset': {
    /** Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state. */
    post: operations['resetConnection']
  }
  '/v1/connections/clear': {
    /** Clear the data for the connection. Deletes data generated by the connection in the destination. Clear any cursors back to initial state. */
    post: operations['clearConnection']
  }
  '/v1/connections/auto_disable': {
    /** Sets connection to inactive if it has met any of the auto-disable conditions (i.e. it hits the max number of consecutive job failures or if it hits the max number of days with only failed jobs). Additionally, notifications will be sent if a connection is disabled or warned if it has reached halfway to disable limits. This endpoint is only able to inactivate connections with more than one non-cancelled job. */
    post: operations['autoDisableConnection']
  }
  '/v1/connections/clear/stream': {
    /** Clear the data for a specific stream in the connection. Deletes data generated by the stream in the destination. Clear any cursors back to initial state. */
    post: operations['clearConnectionStream']
  }
  '/v1/connections/reset/stream': {
    /** Reset the data for a specific stream in the connection. Deletes data generated by the stream in the destination. Resets any cursors back to initial state. */
    post: operations['resetConnectionStream']
  }
  '/v1/connections/refresh': {
    /** refresh the data for specific streams in the connection. If no stream is specify or the list of stream is empy, all the streams will be refreshed. Resets any cursors back to initial state. */
    post: operations['refreshConnectionStream']
  }
  '/v1/connections/get_task_queue_name': {
    /** Gets the string task queue name for a connection and job type. */
    post: operations['getTaskQueueName']
  }
  '/v1/operations/check': {
    /** Check if an operation to be created is valid */
    post: operations['checkOperation']
  }
  '/v1/operations/create': {
    /** Create an operation to be applied as part of a connection pipeline */
    post: operations['createOperation']
  }
  '/v1/operations/update': {
    /** Update an operation */
    post: operations['updateOperation']
  }
  '/v1/operations/list': {
    /**
     * Returns all operations for a connection.
     * @description List operations for connection.
     */
    post: operations['listOperationsForConnection']
  }
  '/v1/operations/get': {
    /** Returns an operation */
    post: operations['getOperation']
  }
  '/v1/operations/delete': {
    /** Delete an operation */
    post: operations['deleteOperation']
  }
  '/v1/scheduler/sources/check_connection': {
    /** Run check connection for a given source configuration */
    post: operations['executeSourceCheckConnection']
  }
  '/v1/scheduler/sources/discover_schema': {
    /** Run discover schema for a given source a source configuration */
    post: operations['executeSourceDiscoverSchema']
  }
  '/v1/scheduler/destinations/check_connection': {
    /** Run check connection for a given destination configuration */
    post: operations['executeDestinationCheckConnection']
  }
  '/v1/source_oauths/oauth_params/create': {
    /** Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
    post: operations['setInstancewideSourceOauthParams']
  }
  '/v1/source_oauths/get_consent_url': {
    /** Given a source connector definition ID, return the URL to the consent screen where to redirect the user to. */
    post: operations['getSourceOAuthConsent']
  }
  '/v1/source_oauths/complete_oauth': {
    /** Given a source def ID generate an access/refresh token etc. */
    post: operations['completeSourceOAuth']
  }
  '/v1/source_oauths/revoke': {
    /** Given a source definition ID and workspace ID revoke access/refresh token etc. */
    post: operations['revokeSourceOAuthTokens']
  }
  '/v1/destination_oauths/get_consent_url': {
    /** Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to. */
    post: operations['getDestinationOAuthConsent']
  }
  '/v1/destination_oauths/complete_oauth': {
    /** Given a destination def ID generate an access/refresh token etc. */
    post: operations['completeDestinationOAuth']
  }
  '/v1/destination_oauths/oauth_params/create': {
    /** Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
    post: operations['setInstancewideDestinationOauthParams']
  }
  '/v1/web_backend/check_updates': {
    /** Returns a summary of source and destination definitions that could be updated. */
    post: operations['webBackendCheckUpdates']
  }
  '/v1/web_backend/connections/list': {
    /** Returns all non-deleted connections for a workspace. */
    post: operations['webBackendListConnectionsForWorkspace']
  }
  '/v1/web_backend/connections/get': {
    /** Get a connection */
    post: operations['webBackendGetConnection']
  }
  '/v1/web_backend/connections/create': {
    /** Create a connection */
    post: operations['webBackendCreateConnection']
  }
  '/v1/web_backend/connections/update': {
    /**
     * Update a connection
     * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
     * Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the
     * connection along with the rest of the operationIds in the request body.
     * Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
     * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
     * with the catalog from the request. This means that to modify a single stream, the entire new catalog
     * containing the updated stream needs to be sent.
     */
    post: operations['webBackendUpdateConnection']
  }
  '/v1/web_backend/state/get_type': {
    /** Fetch the current state type for a connection. */
    post: operations['getStateType']
  }
  '/v1/web_backend/workspace/state': {
    /** Returns the current state of a workspace */
    post: operations['webBackendGetWorkspaceState']
  }
  '/v1/web_backend/geographies/list': {
    /**
     * Returns available geographies can be selected to run data syncs in a particular geography.
     * The 'auto' entry indicates that the sync will be automatically assigned to a geography according
     * to the platform default behavior. Entries other than 'auto' are two-letter country codes that
     * follow the ISO 3166-1 alpha-2 standard.
     *
     * @description Returns all available geographies in which a data sync can run.
     */
    post: operations['webBackendListGeographies']
  }
  '/v1/jobs/create': {
    /** Creates a new job for a given connection. If a job is already running for the connection, it will be stopped and a new job will be created. */
    post: operations['createJob']
  }
  '/v1/jobs/job_success_with_attempt_number': {
    /** For worker to mark an attempt as successful. */
    post: operations['jobSuccessWithAttemptNumber']
  }
  '/v1/jobs/list': {
    /** Returns recent jobs for a connection. Jobs are returned in descending order by createdAt. */
    post: operations['listJobsFor']
  }
  '/v1/jobs/list_for_workspaces': {
    /** Returns recent jobs for a connection. Jobs are returned in descending order by createdAt. */
    post: operations['listJobsForWorkspaces']
  }
  '/v1/jobs/get': {
    /** Get information about a job */
    post: operations['getJobInfo']
  }
  '/v1/jobs/get_last_replication_job': {
    post: operations['getLastReplicationJob']
  }
  '/v1/jobs/get_without_logs': {
    /** Get information about a job excluding logs */
    post: operations['getJobInfoWithoutLogs']
  }
  '/v1/jobs/get_light': {
    /** Get information about a job excluding attempt info and logs */
    post: operations['getJobInfoLight']
  }
  '/v1/jobs/cancel': {
    /** Cancels a job */
    post: operations['cancelJob']
  }
  '/v1/jobs/get_debug_info': {
    /** Gets all information needed to debug this job */
    post: operations['getJobDebugInfo']
  }
  '/v1/jobs/get_normalization_status': {
    /** Get normalization status to determine if we can bypass normalization phase */
    post: operations['getAttemptNormalizationStatusesForJob']
  }
  '/v1/jobs/get_input': {
    /** Get the job input in order to be able to start a synchronization. */
    post: operations['getJobInput']
  }
  '/v1/jobs/get_check_input': {
    /** Get the check job input */
    post: operations['getCheckInput']
  }
  '/v1/jobs/fail_non_terminal': {
    /** Fails all non-terminal jobs for a connection */
    post: operations['failNonTerminalJobs']
  }
  '/v1/jobs/reportJobStart': {
    /** For worker to report when a job starts. */
    post: operations['reportJobStart']
  }
  '/v1/jobs/job_failure': {
    /** Marks a job as failed */
    post: operations['jobFailure']
  }
  '/v1/jobs/delete_stream_reset_records': {
    /** Deletes all stream reset records for the specified job */
    post: operations['deleteStreamResetRecordsForJob']
  }
  '/v1/users/create': {
    /** Creates an Airbyte user */
    post: operations['createUser']
  }
  '/v1/users/get': {
    /** Find Airbyte user by internal user ID */
    post: operations['getUser']
  }
  '/v1/users/get_by_auth_id': {
    /** Find Airbyte user by auth id */
    post: operations['getUserByAuthId']
  }
  '/v1/users/get_by_email': {
    /** Find Airbyte user by email */
    post: operations['getUserByEmail']
  }
  '/v1/users/get_or_create_by_auth_id': {
    /** Find Airbyte user by auth id. If not existed, will create a user. */
    post: operations['getOrCreateUserByAuthId']
  }
  '/v1/users/update': {
    /** Update user state */
    post: operations['updateUser']
  }
  '/v1/users/delete': {
    /** Deletes a user */
    post: operations['deleteUser']
  }
  '/v1/users/list_by_workspace_id': {
    /** List all users in a workspace */
    post: operations['listUsersInWorkspace']
  }
  '/v1/users/list_access_info_by_workspace_id': {
    /** List user access info for a particular workspace. */
    post: operations['listAccessInfoByWorkspaceId']
  }
  '/v1/users/list_by_organization_id': {
    /** List all users with permissions of the given org */
    post: operations['listUsersInOrganization']
  }
  '/v1/users/list_instance_admin': {
    /** List all users with instance admin permissions. Only instance admin has permission to call this. */
    post: operations['listInstanceAdminUsers']
  }
  '/v1/permissions/create': {
    /** Creates a permission resource */
    post: operations['createPermission']
  }
  '/v1/permissions/get': {
    /** Find a permission by ID */
    post: operations['getPermission']
  }
  '/v1/permissions/check': {
    /** Check permissions for user */
    post: operations['checkPermissions']
  }
  '/v1/permissions/check_multiple_workspaces': {
    /** Check permissions for user across workspaces */
    post: operations['checkPermissionsAcrossMultipleWorkspaces']
  }
  '/v1/permissions/update': {
    /** Updates a permission resource */
    post: operations['updatePermission']
  }
  '/v1/secrets_persistence_config/get': {
    /** Get secrets persistence config */
    post: operations['getSecretsPersistenceConfig']
  }
  '/v1/secrets_persistence_config/create_or_update': {
    /** Create or update secrets persistence config */
    post: operations['createOrUpdateSecretsPersistenceConfig']
  }
  '/v1/permissions/delete': {
    /** Deletes a permission resource */
    post: operations['deletePermission']
  }
  '/v1/permissions/delete_user_from_workspace': {
    /** Deletes all workspace-level permissions for a particular user and workspace */
    post: operations['deleteUserFromWorkspace']
  }
  '/v1/permissions/list_by_user': {
    /** List permissions a user has access to */
    post: operations['listPermissionsByUser']
  }
  '/v1/health': {
    /** Health Check */
    get: operations['getHealthCheck']
  }
  '/v1/openapi': {
    /** Returns the openapi specification */
    get: operations['getOpenApiSpec']
  }
  '/v1/attempt/create_new_attempt_number': {
    /** For worker to create a new attempt number. */
    post: operations['createNewAttemptNumber']
  }
  '/v1/attempt/set_workflow_in_attempt': {
    /** For worker to register the workflow id in attempt. */
    post: operations['setWorkflowInAttempt']
  }
  '/v1/attempt/save_stats': {
    /** For worker to set sync stats of a running attempt. */
    post: operations['saveStats']
  }
  '/v1/attempt/save_sync_config': {
    /** For worker to save the AttemptSyncConfig for an attempt. */
    post: operations['saveSyncConfig']
  }
  '/v1/attempt/fail': {
    /** Fails an attempt with a failure summary and if provided a sync output. */
    post: operations['failAttempt']
  }
  '/v1/attempt/get_combined_stats': {
    /** For retrieving combined stats for a single attempt */
    post: operations['getAttemptCombinedStats']
  }
  '/v1/attempt/get_for_job': {
    /** Retrieves an attempt with logs for a job and attempt number. */
    post: operations['getAttemptForJob']
  }
  '/v1/stream_statuses/list': {
    /** Gets a list of stream statuses filtered by parameters (with AND semantics). */
    post: operations['getStreamStatuses']
  }
  '/v1/stream_statuses/latest_per_run_state': {
    /** Gets a list of the latest stream status for each stream and run state for a connection. */
    post: operations['getStreamStatusesByRunState']
  }
  '/v1/stream_statuses/create': {
    /** Creates a stream status. */
    post: operations['createStreamStatus']
  }
  '/v1/stream_statuses/update': {
    /** Updates a stream status. */
    post: operations['updateStreamStatus']
  }
  '/v1/instance_configuration': {
    /** Get instance configuration */
    get: operations['getInstanceConfiguration']
  }
  '/v1/instance_configuration/setup': {
    /** Setup an instance with user and organization information. */
    post: operations['setupInstanceConfiguration']
  }
  '/v1/jobs/retry_states/create_or_update': {
    /** Creates or updates a retry state for a job. */
    post: operations['createOrUpdate']
  }
  '/v1/jobs/retry_states/get': {
    /** Gets a retry state. */
    post: operations['get']
  }
  '/v1/jobs/did_previous_job_succeed': {
    /** Returns whether the job preceding the specified job succeeded */
    post: operations['didPreviousJobSucceed']
  }
  '/v1/jobs/persist_cancellation': {
    /** Persists the cancellation of a job and kicks off any post processing (e.g notifications). */
    post: operations['persistJobCancellation']
  }
  '/v1/organizations/get': {
    /** Get an organization info */
    post: operations['getOrganization']
  }
  '/v1/organizations/create': {
    /** Create an organization */
    post: operations['createOrganization']
  }
  '/v1/organizations/update': {
    /** Update an organization info */
    post: operations['updateOrganization']
  }
  '/v1/organizations/delete': {
    /** Delete an organization */
    post: operations['deleteOrganization']
  }
  '/v1/organizations/list_by_user_id': {
    /** List organizations by a given user id. The function also supports searching by keyword and pagination. */
    post: operations['listOrganizationsByUser']
  }
  '/v1/deployment/metadata': {
    /** Provides the Airbyte deployment metadata. */
    post: operations['getDeploymentMetadata']
  }
  '/v1/applications/list': {
    /**
     * Returns all Applications for a User.
     * @description List Applications for a User.
     */
    post: operations['listApplications']
  }
  '/v1/applications/delete': {
    /**
     * Deletes an Application.
     * @description Deletes an Application.
     */
    post: operations['deleteApplication']
  }
  '/v1/applications/create': {
    /**
     * Creates a new Application.
     * @description Creates a new Application.
     */
    post: operations['createApplication']
  }
  '/v1/applications/token': {
    /**
     * Grant an Access Token for an Application.
     * @description Takes the client_id and client_secret for an application and returns an Access Token.
     */
    post: operations['applicationTokenRequest']
  }
  '/v1/scoped_configuration/list': {
    /** Get all scoped configurations with a given key */
    post: operations['getScopedConfigurationsList']
  }
  '/v1/scoped_configuration/get_context': {
    /** Get related configurations for a given scope */
    post: operations['getScopedConfigurationContext']
  }
  '/v1/scoped_configuration/create': {
    /** Create a new scoped configuration */
    post: operations['createScopedConfiguration']
  }
  '/v1/scoped_configuration/get': {
    /** Get a scoped configuration by ID */
    post: operations['getScopedConfigurationById']
  }
  '/v1/scoped_configuration/update': {
    /** Update a scoped configuration by ID */
    post: operations['updateScopedConfiguration']
  }
  '/v1/scoped_configuration/delete': {
    /** Delete a scoped configuration by ID */
    post: operations['deleteScopedConfiguration']
  }
  '/v1/user_invitations/create': {
    /** Create a user invitation */
    post: operations['createUserInvitation']
  }
  '/v1/user_invitations/by_code/{inviteCode}': {
    /** Get a user invitation by its unique code (not primary key ID) */
    get: operations['getUserInvitation']
  }
  '/v1/user_invitations/list_pending': {
    /** List pending invitations */
    post: operations['listPendingInvitations']
  }
  '/v1/user_invitations/accept': {
    /** Accept a user invitation */
    post: operations['acceptUserInvitation']
  }
  '/v1/user_invitations/decline': {
    /** Decline a user invitation */
    post: operations['declineUserInvitation']
  }
  '/v1/user_invitations/cancel': {
    /** Cancel a user invitation */
    post: operations['cancelUserInvitation']
  }
  '/public': {
    /** Root path, currently returns a redirect to the documentation */
    get: operations['getDocumentation']
  }
  '/public/v1/health': {
    /** Health Check */
    get: operations['publicGetHealthCheck']
  }
  '/public/v1/jobs': {
    /** List Jobs by sync type */
    get: operations['listJobs']
    /** Trigger a sync or reset job of a connection */
    post: operations['publicCreateJob']
  }
  '/public/v1/jobs/{jobId}': {
    /** Get Job status and details */
    get: operations['getJob']
    /** Cancel a running Job */
    delete: operations['publicCancelJob']
    parameters: {
      path: {
        jobId: number
      }
    }
  }
  '/public/v1/sources': {
    /** List sources */
    get: operations['listSources']
    /**
     * Create a source
     * @description Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
     */
    post: operations['publicCreateSource']
  }
  '/public/v1/sources/{sourceId}': {
    /** Get Source details */
    get: operations['publicGetSource']
    /** Update a Source and fully overwrite it */
    put: operations['putSource']
    /** Delete a Source */
    delete: operations['publicDeleteSource']
    /** Update a Source */
    patch: operations['patchSource']
    parameters: {
      path: {
        sourceId: string
      }
    }
  }
  '/public/v1/destinations': {
    /** List destinations */
    get: operations['listDestinations']
    /**
     * Create a destination
     * @description Creates a destination given a name, workspace id, and a json blob containing the configuration for the source.
     */
    post: operations['publicCreateDestination']
  }
  '/public/v1/destinations/{destinationId}': {
    /** Get Destination details */
    get: operations['publicGetDestination']
    /** Update a Destination and fully overwrite it */
    put: operations['putDestination']
    /** Delete a Destination */
    delete: operations['publicDeleteDestination']
    /** Update a Destination */
    patch: operations['patchDestination']
    parameters: {
      path: {
        destinationId: string
      }
    }
  }
  '/public/v1/oauth/callback': {
    /**
     * Receive OAuth callbacks
     * @description Redirected to by identity providers after authentication.
     */
    get: operations['oauthCallback']
  }
  '/public/v1/sources/initiateOAuth': {
    /**
     * Initiate OAuth for a source
     * @description Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.
     *
     * This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.
     *
     * That secret ID can be used to create a source with credentials in place of actual tokens.
     */
    post: operations['initiateOAuth']
  }
  '/public/v1/connections': {
    /** List connections */
    get: operations['listConnections']
    /** Create a connection */
    post: operations['publicCreateConnection']
  }
  '/public/v1/connections/{connectionId}': {
    /** Get Connection details */
    get: operations['publicGetConnection']
    /** Delete a Connection */
    delete: operations['publicDeleteConnection']
    /** Update Connection details */
    patch: operations['patchConnection']
    parameters: {
      path: {
        connectionId: string
      }
    }
  }
  '/public/v1/streams': {
    /** Get stream properties */
    get: operations['getStreamProperties']
  }
  '/public/v1/workspaces': {
    /** List workspaces */
    get: operations['publicListWorkspaces']
    /** Create a workspace */
    post: operations['publicCreateWorkspace']
  }
  '/public/v1/workspaces/{workspaceId}': {
    /** Get Workspace details */
    get: operations['publicGetWorkspace']
    /** Delete a Workspace */
    delete: operations['publicDeleteWorkspace']
    /** Update a workspace */
    patch: operations['publicUpdateWorkspace']
    parameters: {
      path: {
        workspaceId: string
      }
    }
  }
  '/public/v1/workspaces/{workspaceId}/oauthCredentials': {
    /**
     * Create OAuth override credentials for a workspace and source type.
     * @description Create/update a set of OAuth credentials to override the Airbyte-provided OAuth credentials used for source/destination OAuth.
     * In order to determine what the credential configuration needs to be, please see the connector specification of the relevant  source/destination.
     */
    put: operations['createOrUpdateWorkspaceOAuthCredentials']
    parameters: {
      path: {
        workspaceId: string
      }
    }
  }
  '/public/v1/permissions/{permissionId}': {
    /** Get Permission details */
    get: operations['publicGetPermission']
    /** Delete a Permission */
    delete: operations['publicDeletePermission']
    /** Update a permission */
    patch: operations['publicUpdatePermission']
    parameters: {
      path: {
        permissionId: string
      }
    }
  }
  '/public/v1/permissions': {
    /** List Permissions by user id */
    get: operations['publicListPermissionsByUserId']
    /** Create a permission */
    post: operations['publicCreatePermission']
  }
  '/public/v1/users': {
    /**
     * List users
     * @description Lists users based on provided filters. You can filter on either a list of IDs or a list of emails, but not both. If no filters provided we will list all users by default.
     */
    get: operations['publicListUsers']
  }
}

export type webhooks = Record<string, never>

export interface components {
  schemas: {
    ScopedConfigurationRead: {
      id?: string
      value?: string
      value_name?: string
      description?: string
      reference_url?: string
      config_key?: string
      resource_id?: string
      resource_name?: string
      resource_type?: string
      scope_id?: string
      scope_type?: string
      scope_name?: string
      origin?: string
      origin_type?: string
      origin_name?: string
      /** Format: date-time */
      created_at?: string
      /** Format: date-time */
      updated_at?: string
      /** Format: date */
      expires_at?: string
    }
    ScopedConfigurationListRequestBody: {
      /** @description Key of the configuration to filter by */
      config_key?: string
    }
    ScopedConfigurationListResponse: {
      scopedConfigurations?: components['schemas']['ScopedConfigurationRead'][]
    }
    ScopedConfigurationCreateRequestBody: {
      value: string
      description?: string
      reference_url?: string
      config_key: string
      resource_id: string
      resource_type: string
      scope_id: string
      scope_type: string
      origin: string
      origin_type: string
      /** Format: date */
      expires_at?: string
    }
    ScopedConfigurationCreateResponse: {
      data?: components['schemas']['ScopedConfigurationRead']
    }
    ScopedConfigurationContextRequestBody: {
      config_key: string
      /** Format: UUID */
      resource_id: string
      resource_type: string
      /** Format: UUID */
      scope_id: string
      scope_type: string
    }
    ScopedConfigurationContextResponse: {
      activeConfiguration?: components['schemas']['ScopedConfigurationRead']
      /** @description List of configurations that have been created that will get overridden by the scope currently being configured. */
      ancestorConfigurations?: components['schemas']['ScopedConfigurationRead'][]
      /** @description List of configurations that have been created that will override the scope currently being configured. */
      descendantConfigurations?: components['schemas']['ScopedConfigurationRead'][]
    }
    ScopedConfigurationReadRequestBody: {
      /** Format: uuid */
      scopedConfigurationId: string
    }
    ScopedConfigurationReadResponse: {
      data?: components['schemas']['ScopedConfigurationRead']
    }
    ScopedConfigurationUpdateRequestBody: {
      /** Format: uuid */
      scopedConfigurationId: string
      data: components['schemas']['ScopedConfigurationCreateRequestBody']
    }
    ScopedConfigurationUpdateResponse: {
      data?: components['schemas']['ScopedConfigurationRead']
    }
    ScopedConfigurationDeleteRequestBody: {
      /** Format: uuid */
      scopedConfigurationId: string
    }
    ScopedConfigurationDeleteResponse: {
      /** Format: uuid */
      scopedConfigurationId?: string
    }
    /** Format: uuid */
    WorkspaceId: string
    /** Format: uuid */
    CustomerId: string
    WorkspaceCreate: {
      /** Format: email */
      email?: string
      anonymousDataCollection?: boolean
      name: string
      news?: boolean
      securityUpdates?: boolean
      notifications?: components['schemas']['Notification'][]
      notificationSettings?: components['schemas']['NotificationSettings']
      displaySetupWizard?: boolean
      defaultGeography?: components['schemas']['Geography']
      webhookConfigs?: components['schemas']['WebhookConfigWrite'][]
      organizationId: components['schemas']['OrganizationId']
    }
    WorkspaceCreateWithId: {
      /** Format: uuid */
      id: string
      /** Format: email */
      email?: string
      anonymousDataCollection?: boolean
      name: string
      news?: boolean
      securityUpdates?: boolean
      notifications?: components['schemas']['Notification'][]
      notificationSettings?: components['schemas']['NotificationSettings']
      displaySetupWizard?: boolean
      defaultGeography?: components['schemas']['Geography']
      webhookConfigs?: components['schemas']['WebhookConfigWrite'][]
      organizationId: components['schemas']['OrganizationId']
    }
    WebhookConfigWrite: {
      /** @description human readable name for this webhook e.g. for UI display. */
      name?: string
      /** @description an auth token, to be passed as the value for an HTTP Authorization header. */
      authToken?: string
      /** @description if supplied, the webhook config will be validated by checking that this URL returns a 2xx response. */
      validationUrl?: string
    }
    NotificationItem: {
      notificationType?: components['schemas']['NotificationType'][]
      slackConfiguration?: components['schemas']['SlackNotificationConfiguration']
      customerioConfiguration?: components['schemas']['CustomerioNotificationConfiguration']
    }
    NotificationSettings: {
      sendOnSuccess?: components['schemas']['NotificationItem']
      sendOnFailure?: components['schemas']['NotificationItem']
      sendOnSyncDisabled?: components['schemas']['NotificationItem']
      sendOnSyncDisabledWarning?: components['schemas']['NotificationItem']
      sendOnConnectionUpdate?: components['schemas']['NotificationItem']
      sendOnConnectionUpdateActionRequired?: components['schemas']['NotificationItem']
      sendOnBreakingChangeWarning?: components['schemas']['NotificationItem']
      sendOnBreakingChangeSyncsDisabled?: components['schemas']['NotificationItem']
    }
    Notification: {
      notificationType: components['schemas']['NotificationType']
      /** @default false */
      sendOnSuccess: boolean
      /** @default true */
      sendOnFailure: boolean
      slackConfiguration?: components['schemas']['SlackNotificationConfiguration']
      customerioConfiguration?: components['schemas']['CustomerioNotificationConfiguration']
    }
    SlackNotificationConfiguration: {
      webhook: string
    }
    CustomerioNotificationConfiguration: Record<string, never>
    /** @enum {string} */
    NotificationType: 'slack' | 'customerio'
    /** @enum {string} */
    NotificationTrigger:
      | 'sync_success'
      | 'sync_failure'
      | 'sync_disabled'
      | 'sync_disabled_warning'
      | 'connection_update'
      | 'connection_update_action_required'
      | 'breaking_change_warning'
      | 'breaking_change_syncs_disabled'
    NotificationRead: {
      /** @enum {string} */
      status: 'succeeded' | 'failed'
      message?: string
    }
    WorkspaceIdRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      includeTombstone?: boolean
    }
    ListConnectionsForWorkspacesRequestBody: {
      workspaceIds: components['schemas']['WorkspaceId'][]
      /** Format: uuid */
      userId: string
      pagination?: components['schemas']['Pagination']
      /** @default false */
      includeDeleted?: boolean
    }
    ListResourcesForWorkspacesRequestBody: {
      workspaceIds: components['schemas']['WorkspaceId'][]
      /** @default false */
      includeDeleted?: boolean
      pagination: components['schemas']['Pagination']
      nameContains?: string
    }
    WorkspaceReadList: {
      workspaces: components['schemas']['WorkspaceRead'][]
    }
    WorkspaceRead: {
      workspaceId: components['schemas']['WorkspaceId']
      customerId: components['schemas']['CustomerId']
      /** Format: email */
      email?: string
      name: string
      slug: string
      initialSetupComplete: boolean
      displaySetupWizard?: boolean
      anonymousDataCollection?: boolean
      news?: boolean
      securityUpdates?: boolean
      notifications?: components['schemas']['Notification'][]
      notificationSettings?: components['schemas']['NotificationSettings']
      firstCompletedSync?: boolean
      feedbackDone?: boolean
      defaultGeography?: components['schemas']['Geography']
      webhookConfigs?: components['schemas']['WebhookConfigRead'][]
      organizationId: components['schemas']['OrganizationId']
      tombstone?: boolean
    }
    /** @description Limited info about a workspace's organization that is safe to expose to workspace readers who are not members of the org. */
    WorkspaceOrganizationInfoRead: {
      /** Format: uuid */
      organizationId: string
      organizationName: string
      pba: boolean
      sso: boolean
    }
    /** @description the readable info for a webhook config; omits sensitive info e.g. auth token */
    WebhookConfigRead: {
      /** Format: uuid */
      id: string
      /** @description human-readable name e.g. for display in UI */
      name?: string
    }
    WorkspaceUpdateName: {
      workspaceId: components['schemas']['WorkspaceId']
      name: string
    }
    WorkspaceUpdateOrganization: {
      workspaceId: components['schemas']['WorkspaceId']
      organizationId: components['schemas']['OrganizationId']
    }
    /** @description Used to apply a patch-style update to a workspace, which means that null properties remain unchanged */
    WorkspaceUpdate: {
      workspaceId: components['schemas']['WorkspaceId']
      /** Format: email */
      email?: string
      initialSetupComplete?: boolean
      displaySetupWizard?: boolean
      anonymousDataCollection?: boolean
      news?: boolean
      securityUpdates?: boolean
      notifications?: components['schemas']['Notification'][]
      notificationSettings?: components['schemas']['NotificationSettings']
      defaultGeography?: components['schemas']['Geography']
      webhookConfigs?: components['schemas']['WebhookConfigWrite'][]
    }
    WorkspaceGiveFeedback: {
      workspaceId: components['schemas']['WorkspaceId']
    }
    WebBackendWorkspaceState: {
      workspaceId: components['schemas']['WorkspaceId']
    }
    WebBackendWorkspaceStateResult: {
      hasConnections: boolean
      hasSources: boolean
      hasDestinations: boolean
    }
    WebBackendGeographiesListResult: {
      geographies: components['schemas']['Geography'][]
    }
    SlugRequestBody: {
      slug: string
    }
    /** @enum {string} */
    Geography: 'auto' | 'us' | 'eu'
    /** Format: uuid */
    ConnectorBuilderProjectId: string
    /** @description Low code CDK manifest JSON object */
    DeclarativeManifest: Record<string, never>
    DeclarativeManifestRead: {
      manifest?: components['schemas']['DeclarativeManifest']
      isDraft?: boolean
      version?: components['schemas']['ManifestVersion']
      description?: string
    }
    ConnectorBuilderProjectDetails: {
      name: string
      draftManifest?: components['schemas']['DeclarativeManifest']
      yamlManifest?: string
    }
    ConnectorBuilderProjectDetailsRead: {
      name: string
      builderProjectId: components['schemas']['ConnectorBuilderProjectId']
      sourceDefinitionId?: components['schemas']['SourceDefinitionId']
      activeDeclarativeManifestVersion?: components['schemas']['ManifestVersion']
      hasDraft: boolean
    }
    ConnectorBuilderProjectIdWithWorkspaceId: {
      workspaceId: components['schemas']['WorkspaceId']
      builderProjectId: components['schemas']['ConnectorBuilderProjectId']
      version?: components['schemas']['ManifestVersion']
    }
    ExistingConnectorBuilderProjectWithWorkspaceId: {
      workspaceId: components['schemas']['WorkspaceId']
      builderProjectId: components['schemas']['ConnectorBuilderProjectId']
      builderProject: components['schemas']['ConnectorBuilderProjectDetails']
    }
    ConnectorBuilderProjectWithWorkspaceId: {
      workspaceId: components['schemas']['WorkspaceId']
      builderProject: components['schemas']['ConnectorBuilderProjectDetails']
    }
    ConnectorBuilderProjectRead: {
      builderProject: components['schemas']['ConnectorBuilderProjectDetailsRead']
      declarativeManifest?: components['schemas']['DeclarativeManifestRead']
      testingValues?: components['schemas']['ConnectorBuilderProjectTestingValues']
    }
    /** @description The config blob containing the user inputs for testing */
    ConnectorBuilderProjectTestingValues: Record<string, never>
    ConnectorBuilderProjectReadList: {
      projects: components['schemas']['ConnectorBuilderProjectDetailsRead'][]
    }
    ConnectorBuilderPublishRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      builderProjectId: components['schemas']['ConnectorBuilderProjectId']
      name: string
      initialDeclarativeManifest: components['schemas']['DeclarativeSourceManifest']
    }
    ConnectorBuilderProjectTestingValuesUpdate: {
      workspaceId: components['schemas']['WorkspaceId']
      builderProjectId: components['schemas']['ConnectorBuilderProjectId']
      spec: components['schemas']['SourceDefinitionSpecification']
      testingValues: components['schemas']['ConnectorBuilderProjectTestingValues']
    }
    ConnectorBuilderProjectStreamReadRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      builderProjectId: components['schemas']['ConnectorBuilderProjectId']
      manifest: components['schemas']['DeclarativeManifest']
      /** @description Name of the stream to read */
      streamName: string
      /**
       * @description Indicates if the manifest was auto-generated from the form-based Connector Builder UI
       * @default false
       */
      formGeneratedManifest?: boolean
      /**
       * @description Maximum number of records that will be returned to the client from connector builder test reads
       * @default 1000
       */
      recordLimit?: number
      /**
       * @description Maximum number of pages that will be returned to the client from connector builder test reads
       * @default 5
       */
      pageLimit?: number
      /**
       * @description Maximum number of slices that will be returned to the client from connector builder test reads
       * @default 5
       */
      sliceLimit?: number
      state?: Record<string, never>[]
    }
    ConnectorBuilderProjectStreamRead: {
      /** @description The LOG AirbyteMessages that were emitted during the read of this slice */
      logs: Record<string, never>[]
      /** @description The stream slices returned from the read command. If no stream slicer is configured, this should contain a single item containing all of the results. */
      slices: {
        /** @description The pages returned from the read command. If no pagination is configured, this should contain a single item containing all of the results. */
        pages: {
          /** @description The RECORD AirbyteMessages coming from the read operation for this page */
          records: Record<string, never>[]
          request?: components['schemas']['ConnectorBuilderHttpRequest']
          response?: components['schemas']['ConnectorBuilderHttpResponse']
        }[]
        /** @description An object describing the current slice. This can be omitted if a stream slicer is not configured. */
        slice_descriptor?: Record<string, never>
        state?: Record<string, never>[]
      }[]
      /** @description Whether the maximum number of request per slice or the maximum number of slices queried has been reached */
      test_read_limit_reached: boolean
      auxiliary_requests?: {
        description: string
        request: components['schemas']['ConnectorBuilderHttpRequest']
        response: components['schemas']['ConnectorBuilderHttpResponse']
        title: string
      }[]
      /** @description The narrowest JSON Schema against which every AirbyteRecord in the slices can validate successfully. This is inferred from reading every record in the output slices. */
      inferred_schema?: Record<string, never>
      /** @description Fields that match the given datetime format in every encountered record. The property names are the fields, the property values are the datetime formats. */
      inferred_datetime_formats?: Record<string, never>
      /** @description The latest configuration emitted by the platform. The connector builder uses this to update its state when a new configuration is generated, to ensure that the user always work with the latest configuration. */
      latest_config_update?: components['schemas']['ConnectorBuilderProjectTestingValues']
    }
    ConnectorBuilderHttpRequest: {
      /** @description URL that the request was sent to */
      url: string
      /** @description The request parameters that were set on the HTTP request, if any */
      parameters?: Record<string, never>
      /** @description The body of the HTTP request, if present */
      body?: string
      /** @description The headers of the HTTP request, if any */
      headers?: Record<string, never>
      /**
       * @description The http method of the request ("GET", "POST", "PUT", or "PATCH")
       * @enum {string}
       */
      http_method: 'GET' | 'POST' | 'PUT' | 'PATCH'
    }
    ConnectorBuilderHttpResponse: {
      /** @description The status of the response */
      status: number
      /** @description The body of the HTTP response, if present */
      body?: string
      /** @description The headers of the HTTP response, if any */
      headers?: Record<string, never>
    }
    /** Format: int64 */
    ManifestVersion: number
    DeclarativeSourceManifest: {
      description: string
      manifest: components['schemas']['DeclarativeManifest']
      spec: components['schemas']['SourceDefinitionSpecification']
      version: components['schemas']['ManifestVersion']
    }
    SourceDefinitionIdBody: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
    }
    ConnectorDocumentationRequestBody: {
      actorType: components['schemas']['ActorType']
      actorDefinitionId: components['schemas']['ActorDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
      actorId?: components['schemas']['ActorId']
    }
    ConnectorDocumentationRead: {
      doc: string
    }
    /** Format: uuid */
    SourceDefinitionId: string
    SourceDefinitionIdRequestBody: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
    }
    SourceDefinitionCreate: {
      name: string
      dockerRepository: string
      dockerImageTag: string
      /** Format: uri */
      documentationUrl: string
      icon?: string
      resourceRequirements?: components['schemas']['ActorDefinitionResourceRequirements']
    }
    /** @description Update the SourceDefinition. Currently, the only allowed attribute to update is the default docker image version. */
    SourceDefinitionUpdate: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      dockerImageTag: string
      resourceRequirements?: components['schemas']['ActorDefinitionResourceRequirements']
    }
    SourceDefinitionRead: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      name: string
      dockerRepository: string
      dockerImageTag: string
      /** Format: uri */
      documentationUrl?: string
      icon?: string
      /** @description The Airbyte Protocol version supported by the connector */
      protocolVersion?: string
      /**
       * @description Whether the connector is custom or not
       * @default false
       */
      custom?: boolean
      supportLevel?: components['schemas']['SupportLevel']
      releaseStage?: components['schemas']['ReleaseStage']
      /**
       * Format: date
       * @description The date when this connector was first released, in yyyy-mm-dd format.
       */
      releaseDate?: string
      /** @enum {string} */
      sourceType?: 'api' | 'file' | 'database' | 'custom'
      resourceRequirements?: components['schemas']['ActorDefinitionResourceRequirements']
      /**
       * Format: int64
       * @description Number of seconds allowed between 2 airbyte protocol messages. The source will timeout if this delay is reach
       */
      maxSecondsBetweenMessages?: number
    }
    SourceDefinitionReadList: {
      sourceDefinitions: components['schemas']['SourceDefinitionRead'][]
    }
    /** Format: uuid */
    ScopeId: string
    /** @enum {string} */
    ScopeType: 'workspace' | 'organization'
    CustomSourceDefinitionCreate: {
      workspaceId?: components['schemas']['WorkspaceId']
      scopeId?: components['schemas']['ScopeId']
      scopeType?: components['schemas']['ScopeType']
      sourceDefinition: components['schemas']['SourceDefinitionCreate']
    }
    SourceDefinitionIdWithWorkspaceId: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
    }
    ActorDefinitionIdWithScope: {
      actorDefinitionId: components['schemas']['ActorDefinitionId']
      scopeId: components['schemas']['ScopeId']
      scopeType: components['schemas']['ScopeType']
    }
    ResolveActorDefinitionVersionRequestBody: {
      actorDefinitionId: components['schemas']['ActorDefinitionId']
      actorType: components['schemas']['ActorType']
      dockerImageTag: string
    }
    ListDeclarativeManifestsRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
    }
    DeclarativeManifestsReadList: {
      manifestVersions: components['schemas']['DeclarativeManifestVersionRead'][]
    }
    DeclarativeManifestVersionRead: {
      /** Format: int64 */
      version: number
      isActive: boolean
      description: string
    }
    DeclarativeSourceDefinitionCreateManifestRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      sourceDefinitionId: components['schemas']['ConnectorBuilderProjectId']
      setAsActiveManifest: boolean
      declarativeManifest: components['schemas']['DeclarativeSourceManifest']
    }
    UpdateActiveManifestRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      sourceDefinitionId: components['schemas']['ConnectorBuilderProjectId']
      version: components['schemas']['ManifestVersion']
    }
    PrivateSourceDefinitionRead: {
      sourceDefinition: components['schemas']['SourceDefinitionRead']
      granted: boolean
    }
    PrivateSourceDefinitionReadList: {
      sourceDefinitions: components['schemas']['PrivateSourceDefinitionRead'][]
    }
    /**
     * @description The specification for what values are required to configure the sourceDefinition.
     * @example {
     *   "user": {
     *     "type": "string"
     *   }
     * }
     */
    SourceDefinitionSpecification: Record<string, never>
    SourceDefinitionSpecificationRead: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      documentationUrl?: string
      connectionSpecification?: components['schemas']['SourceDefinitionSpecification']
      advancedAuth?: components['schemas']['AdvancedAuth']
      jobInfo: components['schemas']['SynchronousJobRead']
    }
    /** Format: uuid */
    SourceId: string
    SourceIdRequestBody: {
      sourceId: components['schemas']['SourceId']
    }
    /** @description The values required to configure the source. The schema for this should have an id of the existing source along with the configuration you want to change in case. */
    SourceCloneRequestBody: {
      sourceCloneId: components['schemas']['SourceId']
      sourceConfiguration?: components['schemas']['SourceCloneConfiguration']
    }
    SourceCloneConfiguration: {
      connectionConfiguration?: components['schemas']['SourceConfiguration']
      name?: string
    }
    /**
     * @description The values required to configure the source. The schema for this must match the schema return by source_definition_specifications/get for the source.
     * @example {
     *   "user": "charles"
     * }
     */
    SourceConfiguration: unknown
    SourceCoreConfig: {
      sourceId?: components['schemas']['SourceId']
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      connectionConfiguration: components['schemas']['SourceConfiguration']
      workspaceId: components['schemas']['WorkspaceId']
    }
    SourceCreate: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      connectionConfiguration: components['schemas']['SourceConfiguration']
      workspaceId: components['schemas']['WorkspaceId']
      name: string
      /** @example airbyte_oauth_workspace_0509f049-d671-48cb-8105-0a23d47e6db6_secret_e0d38206-034e-4d75-9d21-da5a99b02826_v1 */
      secretId?: string
    }
    SourceDiscoverSchemaRequestBody: {
      sourceId: components['schemas']['SourceId']
      /** Format: uuid */
      connectionId?: string
      disable_cache?: boolean
      notifySchemaChange?: boolean
      priority?: components['schemas']['WorkloadPriority']
    }
    /** @enum {string} */
    WorkloadPriority: 'high' | 'default'
    PartialSourceUpdate: {
      sourceId: components['schemas']['SourceId']
      connectionConfiguration?: components['schemas']['SourceConfiguration']
      name?: string
      /** @example airbyte_oauth_workspace_0509f049-d671-48cb-8105-0a23d47e6db6_secret_e0d38206-034e-4d75-9d21-da5a99b02826_v1 */
      secretId?: string
    }
    SourceUpdate: {
      sourceId: components['schemas']['SourceId']
      connectionConfiguration: components['schemas']['SourceConfiguration']
      name: string
      /** @example airbyte_oauth_workspace_0509f049-d671-48cb-8105-0a23d47e6db6_secret_e0d38206-034e-4d75-9d21-da5a99b02826_v1 */
      secretId?: string
    }
    SourceRead: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      sourceId: components['schemas']['SourceId']
      workspaceId: components['schemas']['WorkspaceId']
      connectionConfiguration: components['schemas']['SourceConfiguration']
      name: string
      sourceName: string
      icon?: string
      isVersionOverrideApplied?: boolean
      breakingChanges?: components['schemas']['ActorDefinitionVersionBreakingChanges']
      supportState?: components['schemas']['SupportState']
    }
    SourceSnippetRead: {
      sourceId: components['schemas']['SourceId']
      name: string
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      sourceName: string
      icon?: string
    }
    SourceReadList: {
      sources: components['schemas']['SourceRead'][]
    }
    /** @description to write this requested object to database. */
    SourceDiscoverSchemaWriteRequestBody: {
      catalog: components['schemas']['AirbyteCatalog']
      sourceId?: components['schemas']['SourceId']
      connectorVersion?: string
      configurationHash?: string
    }
    /** @description Returns the results of a discover catalog job. If the job was not successful, the catalog field will not be present. jobInfo will aways be present and its status be used to determine if the job was successful or not. */
    SourceDiscoverSchemaRead: {
      catalog?: components['schemas']['AirbyteCatalog']
      jobInfo: components['schemas']['SynchronousJobRead']
      /** Format: uuid */
      catalogId?: string
      catalogDiff?: components['schemas']['CatalogDiff']
      breakingChange?: boolean
      connectionStatus?: components['schemas']['ConnectionStatus']
    }
    /** @description Input of the source propagation, it contains the discovered catalog and a list of diff that need to be applied to the existing catalog. */
    SourceAutoPropagateChange: {
      catalog: components['schemas']['AirbyteCatalog']
      /** Format: uuid */
      catalogId: string
      /** Format: uuid */
      sourceId: string
      /** Format: uuid */
      workspaceId: string
    }
    SourceSearch: {
      sourceDefinitionId?: components['schemas']['SourceDefinitionId']
      sourceId?: components['schemas']['SourceId']
      workspaceId?: components['schemas']['WorkspaceId']
      connectionConfiguration?: components['schemas']['SourceConfiguration']
      name?: string
      sourceName?: string
    }
    /** Format: uuid */
    DestinationDefinitionId: string
    DestinationDefinitionIdRequestBody: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
    }
    DestinationDefinitionCreate: {
      name: string
      dockerRepository: string
      dockerImageTag: string
      /** Format: uri */
      documentationUrl: string
      icon?: string
      resourceRequirements?: components['schemas']['ActorDefinitionResourceRequirements']
    }
    DestinationDefinitionUpdate: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      dockerImageTag?: string
      resourceRequirements?: components['schemas']['ActorDefinitionResourceRequirements']
    }
    DestinationDefinitionRead: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      name: string
      dockerRepository: string
      dockerImageTag: string
      /** Format: uri */
      documentationUrl: string
      icon?: string
      /** @description The Airbyte Protocol version supported by the connector */
      protocolVersion?: string
      /**
       * @description Whether the connector is custom or not
       * @default false
       */
      custom?: boolean
      supportLevel?: components['schemas']['SupportLevel']
      releaseStage?: components['schemas']['ReleaseStage']
      /**
       * Format: date
       * @description The date when this connector was first released, in yyyy-mm-dd format.
       */
      releaseDate?: string
      resourceRequirements?: components['schemas']['ActorDefinitionResourceRequirements']
      /** @description an optional flag indicating whether DBT is used in the normalization. If the flag value is NULL - DBT is not used. */
      supportsDbt: boolean
      normalizationConfig: components['schemas']['NormalizationDestinationDefinitionConfig']
      /** @description Indicated that the actor supports the refreshes */
      supportRefreshes: boolean
    }
    DestinationDefinitionReadList: {
      destinationDefinitions: components['schemas']['DestinationDefinitionRead'][]
    }
    CustomDestinationDefinitionCreate: {
      workspaceId?: components['schemas']['WorkspaceId']
      destinationDefinition: components['schemas']['DestinationDefinitionCreate']
      scopeId?: components['schemas']['ScopeId']
      scopeType?: components['schemas']['ScopeType']
    }
    DestinationDefinitionIdWithWorkspaceId: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
    }
    PrivateDestinationDefinitionRead: {
      destinationDefinition: components['schemas']['DestinationDefinitionRead']
      granted: boolean
    }
    PrivateDestinationDefinitionReadList: {
      destinationDefinitions: components['schemas']['PrivateDestinationDefinitionRead'][]
    }
    /**
     * @description The specification for what values are required to configure the destinationDefinition.
     * @example {
     *   "user": {
     *     "type": "string"
     *   }
     * }
     */
    DestinationDefinitionSpecification: Record<string, never>
    DestinationDefinitionSpecificationRead: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      documentationUrl?: string
      connectionSpecification?: components['schemas']['DestinationDefinitionSpecification']
      advancedAuth?: components['schemas']['AdvancedAuth']
      jobInfo: components['schemas']['SynchronousJobRead']
      supportedDestinationSyncModes?: components['schemas']['DestinationSyncMode'][]
    }
    /** Format: uuid */
    DestinationId: string
    DestinationIdRequestBody: {
      destinationId: components['schemas']['DestinationId']
    }
    /**
     * @description The values required to configure the destination. The schema for this must match the schema return by destination_definition_specifications/get for the destinationDefinition.
     * @example {
     *   "user": "charles"
     * }
     */
    DestinationConfiguration: unknown
    DestinationCoreConfig: {
      destinationId?: components['schemas']['DestinationId']
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      connectionConfiguration: components['schemas']['DestinationConfiguration']
      workspaceId: components['schemas']['WorkspaceId']
    }
    DestinationCreate: {
      workspaceId: components['schemas']['WorkspaceId']
      name: string
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      connectionConfiguration: components['schemas']['DestinationConfiguration']
    }
    DestinationUpdate: {
      destinationId: components['schemas']['DestinationId']
      connectionConfiguration: components['schemas']['DestinationConfiguration']
      name: string
    }
    PartialDestinationUpdate: {
      destinationId?: components['schemas']['DestinationId']
      connectionConfiguration?: components['schemas']['DestinationConfiguration']
      name?: string
    }
    /** @description The values required to configure the destination. The schema for this should have an id of the existing destination along with the configuration you want to change in case. */
    DestinationCloneRequestBody: {
      destinationCloneId: components['schemas']['DestinationId']
      destinationConfiguration?: components['schemas']['DestinationCloneConfiguration']
    }
    DestinationCloneConfiguration: {
      connectionConfiguration?: components['schemas']['DestinationConfiguration']
      name?: string
    }
    DestinationRead: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      destinationId: components['schemas']['DestinationId']
      workspaceId: components['schemas']['WorkspaceId']
      connectionConfiguration: components['schemas']['DestinationConfiguration']
      name: string
      destinationName: string
      icon?: string
      isVersionOverrideApplied?: boolean
      breakingChanges?: components['schemas']['ActorDefinitionVersionBreakingChanges']
      supportState?: components['schemas']['SupportState']
    }
    DestinationSnippetRead: {
      destinationId: components['schemas']['DestinationId']
      name: string
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      destinationName: string
      icon?: string
    }
    DestinationReadList: {
      destinations: components['schemas']['DestinationRead'][]
    }
    DestinationSearch: {
      destinationDefinitionId?: components['schemas']['DestinationDefinitionId']
      destinationId?: components['schemas']['DestinationId']
      workspaceId?: components['schemas']['WorkspaceId']
      connectionConfiguration?: components['schemas']['DestinationConfiguration']
      name?: string
      destinationName?: string
    }
    /** Format: uuid */
    ActorDefinitionVersionId: string
    ActorDefinitionVersionRead: {
      dockerRepository: string
      dockerImageTag: string
      supportsDbt: boolean
      normalizationConfig: components['schemas']['NormalizationDestinationDefinitionConfig']
      isVersionOverrideApplied: boolean
      supportLevel?: components['schemas']['SupportLevel']
      supportState: components['schemas']['SupportState']
      breakingChanges?: components['schemas']['ActorDefinitionVersionBreakingChanges']
    }
    ResolveActorDefinitionVersionResponse: {
      versionId: components['schemas']['ActorDefinitionVersionId']
      dockerRepository: string
      dockerImageTag: string
    }
    ActorDefinitionBreakingChange: {
      version: string
      message: string
      /** Format: date */
      upgradeDeadline: string
      migrationDocumentationUrl: string
    }
    ActorDefinitionVersionBreakingChanges: {
      upcomingBreakingChanges: components['schemas']['ActorDefinitionBreakingChange'][]
      /** Format: date */
      minUpgradeDeadline: string
    }
    /** @enum {string} */
    SupportState: 'supported' | 'unsupported' | 'deprecated'
    /** @enum {string} */
    ReleaseStage: 'alpha' | 'beta' | 'generally_available' | 'custom'
    /** @enum {string} */
    SupportLevel: 'community' | 'certified' | 'archived' | 'none'
    /** Format: uuid */
    ConnectionId: string
    ConnectionIdRequestBody: {
      connectionId: components['schemas']['ConnectionId']
    }
    ConnectionAndJobIdRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      jobId: components['schemas']['JobId']
    }
    ConnectionUptimeHistoryRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      numberOfJobs?: number
    }
    ConnectionDataHistoryRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      numberOfJobs: number
    }
    ConnectionStreamHistoryRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      timezone: string
    }
    ConnectionStream: {
      streamName: string
      streamNamespace?: string
    }
    ConnectionStreamRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      streams: components['schemas']['ConnectionStream'][]
    }
    ConnectionStreamRefreshRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      refreshMode: components['schemas']['RefreshMode']
      streams?: components['schemas']['ConnectionStream'][]
    }
    /** @enum {string} */
    RefreshMode: 'Truncate' | 'Merge'
    DbMigrationRequestBody: {
      database: string
    }
    WebBackendConnectionRequestBody: {
      withRefreshedCatalog?: boolean
      connectionId: components['schemas']['ConnectionId']
    }
    ConnectionCreate: {
      /** @description Optional name of the connection */
      name?: string
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      sourceId: components['schemas']['SourceId']
      destinationId: components['schemas']['DestinationId']
      operationIds?: components['schemas']['OperationId'][]
      syncCatalog?: components['schemas']['AirbyteCatalog']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status: components['schemas']['ConnectionStatus']
      resourceRequirements?: components['schemas']['ResourceRequirements']
      /** Format: uuid */
      sourceCatalogId?: string
      geography?: components['schemas']['Geography']
      notifySchemaChanges?: boolean
      notifySchemaChangesByEmail?: boolean
      nonBreakingChangesPreference?: components['schemas']['NonBreakingChangesPreference']
      backfillPreference?: components['schemas']['SchemaChangeBackfillPreference']
    }
    WebBackendConnectionCreate: {
      /** @description Optional name of the connection */
      name?: string
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      sourceId: components['schemas']['SourceId']
      destinationId: components['schemas']['DestinationId']
      operationIds?: components['schemas']['OperationId'][]
      syncCatalog?: components['schemas']['AirbyteCatalog']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status: components['schemas']['ConnectionStatus']
      resourceRequirements?: components['schemas']['ResourceRequirements']
      operations?: components['schemas']['OperationCreate'][]
      /** Format: uuid */
      sourceCatalogId?: string
      geography?: components['schemas']['Geography']
      notifySchemaChanges?: boolean
      nonBreakingChangesPreference?: components['schemas']['NonBreakingChangesPreference']
      backfillPreference?: components['schemas']['SchemaChangeBackfillPreference']
    }
    ConnectionStateCreateOrUpdate: {
      connectionId: components['schemas']['ConnectionId']
      connectionState: components['schemas']['ConnectionState']
    }
    /** @description Used to apply a patch-style update to a connection, which means that null properties remain unchanged */
    ConnectionUpdate: {
      connectionId: components['schemas']['ConnectionId']
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Name that will be set to this connection */
      name?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      operationIds?: components['schemas']['OperationId'][]
      syncCatalog?: components['schemas']['AirbyteCatalog']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status?: components['schemas']['ConnectionStatus']
      resourceRequirements?: components['schemas']['ResourceRequirements']
      /** Format: uuid */
      sourceCatalogId?: string
      geography?: components['schemas']['Geography']
      notifySchemaChanges?: boolean
      notifySchemaChangesByEmail?: boolean
      nonBreakingChangesPreference?: components['schemas']['NonBreakingChangesPreference']
      backfillPreference?: components['schemas']['SchemaChangeBackfillPreference']
      breakingChange?: boolean
    }
    /** @description Used to apply a patch-style update to a connection, which means that null properties remain unchanged */
    WebBackendConnectionUpdate: {
      /** @description Name that will be set to the connection */
      name?: string
      connectionId: components['schemas']['ConnectionId']
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      syncCatalog?: components['schemas']['AirbyteCatalog']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status?: components['schemas']['ConnectionStatus']
      resourceRequirements?: components['schemas']['ResourceRequirements']
      skipReset?: boolean
      operations?: components['schemas']['WebBackendOperationCreateOrUpdate'][]
      /** Format: uuid */
      sourceCatalogId?: string
      geography?: components['schemas']['Geography']
      notifySchemaChanges?: boolean
      notifySchemaChangesByEmail?: boolean
      nonBreakingChangesPreference?: components['schemas']['NonBreakingChangesPreference']
      backfillPreference?: components['schemas']['SchemaChangeBackfillPreference']
    }
    ConnectionRead: {
      connectionId: components['schemas']['ConnectionId']
      name: string
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      sourceId: components['schemas']['SourceId']
      destinationId: components['schemas']['DestinationId']
      operationIds?: components['schemas']['OperationId'][]
      syncCatalog: components['schemas']['AirbyteCatalog']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status: components['schemas']['ConnectionStatus']
      resourceRequirements?: components['schemas']['ResourceRequirements']
      /** Format: uuid */
      sourceCatalogId?: string
      geography?: components['schemas']['Geography']
      breakingChange: boolean
      notifySchemaChanges?: boolean
      notifySchemaChangesByEmail?: boolean
      nonBreakingChangesPreference?: components['schemas']['NonBreakingChangesPreference']
      /** Format: int64 */
      created_at?: number
      backfillPreference?: components['schemas']['SchemaChangeBackfillPreference']
      workspaceId?: components['schemas']['WorkspaceId']
    }
    ConnectionStatusesRequestBody: {
      connectionIds: components['schemas']['ConnectionId'][]
    }
    ConnectionStatusesRead: components['schemas']['ConnectionStatusRead'][]
    ConnectionStatusRead: {
      connectionId: components['schemas']['ConnectionId']
      lastSyncJobStatus: components['schemas']['JobStatus']
      /** Format: int64 */
      lastSuccessfulSync: number
      lastSyncJobId?: components['schemas']['JobId']
      lastSyncAttemptNumber?: components['schemas']['AttemptNumber']
      /** Format: int64 */
      nextSync: number
      isRunning: boolean
      isLastCompletedJobReset: boolean
      failureReason?: components['schemas']['FailureReason']
    }
    ConnectionSyncProgressRead: {
      /** Format: uuid */
      connectionId: string
      /** Format: int64 */
      jobId?: number
      streams: components['schemas']['StreamSyncProgressReadItem'][]
      /** Format: int64 */
      recordsEmitted?: number
      /** Format: int64 */
      recordsCommitted?: number
      /** Format: int64 */
      bytesEmitted?: number
      /** Format: int64 */
      bytesCommitted?: number
      /** Format: int64 */
      syncStartedAt?: number
    }
    StreamSyncProgressReadItem: {
      streamName: string
      streamNamespace?: string
      /** Format: int64 */
      recordsEmitted?: number
      /** Format: int64 */
      bytesEmitted?: number
      /** Format: int64 */
      recordsCommitted?: number
      /** Format: int64 */
      bytesCommitted?: number
    }
    ConnectionUptimeHistoryRead: components['schemas']['JobSyncResultRead'][]
    JobSyncResultRead: {
      jobId: components['schemas']['JobId']
      /** Format: int64 */
      jobCreatedAt: number
      /** Format: int64 */
      jobUpdatedAt: number
      streamStatuses: components['schemas']['ConnectionSyncResultRead'][]
      configType: components['schemas']['JobConfigType']
      /** Format: int64 */
      recordsEmitted: number
      /** Format: int64 */
      recordsCommitted: number
      /** Format: int64 */
      bytesEmitted: number
      /** Format: int64 */
      bytesCommitted: number
    }
    ConnectionSyncResultRead: {
      status: components['schemas']['JobStatus']
      streamName: string
      streamNamespace: string
    }
    ConnectionDataHistoryRead: components['schemas']['ConnectionDataHistoryReadItem'][]
    ConnectionDataHistoryReadItem: {
      /** Format: int */
      timestamp: number
      /** Format: int64 */
      recordsCommitted: number
      /** Format: int64 */
      recordsEmitted?: number
      /** Format: int64 */
      jobId?: number
    }
    ConnectionStreamHistoryRead: components['schemas']['ConnectionStreamHistoryReadItem'][]
    ConnectionStreamHistoryReadItem: {
      /** Format: int */
      timestamp: number
      streamName: string
      streamNamespace: string
      /** Format: int64 */
      recordsCommitted: number
    }
    /** @enum {string} */
    SchemaChange: 'no_change' | 'non_breaking' | 'breaking'
    ConnectionSearch: {
      connectionId?: components['schemas']['ConnectionId']
      name?: string
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      sourceId?: components['schemas']['SourceId']
      destinationId?: components['schemas']['DestinationId']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status?: components['schemas']['ConnectionStatus']
      source?: components['schemas']['SourceSearch']
      destination?: components['schemas']['DestinationSearch']
    }
    ConnectionReadList: {
      connections: components['schemas']['ConnectionRead'][]
    }
    /**
     * @description Active means that data is flowing through the connection. Inactive means it is not. Deprecated means the connection is off and cannot be re-activated. the schema field describes the elements of the schema that will be synced.
     * @enum {string}
     */
    ConnectionStatus: 'active' | 'inactive' | 'deprecated'
    /** @description if null, then no schedule is set. */
    ConnectionSchedule: {
      /** Format: int64 */
      units: number
      /** @enum {string} */
      timeUnit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months'
    }
    /**
     * @description determine how the schedule data should be interpreted
     * @enum {string}
     */
    ConnectionScheduleType: 'manual' | 'basic' | 'cron'
    /** @description schedule for when the the connection should run, per the schedule type */
    ConnectionScheduleData: {
      basicSchedule?: {
        /** @enum {string} */
        timeUnit: 'minutes' | 'hours' | 'days' | 'weeks' | 'months'
        /** Format: int64 */
        units: number
      }
      cron?: {
        cronExpression: string
        cronTimeZone: string
      }
    }
    /**
     * @description Method used for computing final namespace in destination
     * @enum {string}
     */
    NamespaceDefinitionType: 'source' | 'destination' | 'customformat'
    /** @description Input of the schema propagation, with the catalog to be propagated and the connection to propagate to */
    ConnectionAutoPropagateSchemaChange: {
      catalog: components['schemas']['AirbyteCatalog']
      /** Format: uuid */
      catalogId: string
      /** Format: uuid */
      connectionId: string
      /** Format: uuid */
      workspaceId: string
    }
    /** @description The result of schema propagation for a given connection, with the diff that was applied via auto-propagation. */
    ConnectionAutoPropagateResult: {
      propagatedDiff?: components['schemas']['CatalogDiff']
    }
    /** Format: uuid */
    OperationId: string
    OperationIdRequestBody: {
      operationId: components['schemas']['OperationId']
    }
    OperationCreate: {
      workspaceId: components['schemas']['WorkspaceId']
      name: string
      operatorConfiguration: components['schemas']['OperatorConfiguration']
    }
    OperationUpdate: {
      operationId: components['schemas']['OperationId']
      name: string
      operatorConfiguration: components['schemas']['OperatorConfiguration']
    }
    WebBackendOperationCreateOrUpdate: {
      operationId?: components['schemas']['OperationId']
      workspaceId: components['schemas']['WorkspaceId']
      name: string
      operatorConfiguration: components['schemas']['OperatorConfiguration']
    }
    OperationRead: {
      workspaceId: components['schemas']['WorkspaceId']
      operationId: components['schemas']['OperationId']
      name: string
      operatorConfiguration: components['schemas']['OperatorConfiguration']
    }
    OperationReadList: {
      operations: components['schemas']['OperationRead'][]
    }
    OperatorConfiguration: {
      operatorType: components['schemas']['OperatorType']
      normalization?: components['schemas']['OperatorNormalization']
      dbt?: components['schemas']['OperatorDbt']
      webhook?: components['schemas']['OperatorWebhook']
    }
    /** @enum {string} */
    OperatorType: 'normalization' | 'dbt' | 'webhook'
    OperatorNormalization: {
      /** @enum {string} */
      option?: 'basic'
    }
    OperatorDbt: {
      gitRepoUrl: string
      gitRepoBranch?: string
      dockerImage?: string
      dbtArguments?: string
    }
    OperatorWebhook: {
      /**
       * Format: uuid
       * @description The id of the webhook configs to use from the workspace.
       */
      webhookConfigId?: string
      /** @enum {string} */
      webhookType?: 'dbtCloud'
      dbtCloud?: {
        /** @description The account id associated with the job */
        accountId: number
        /** @description The job id associated with the job */
        jobId: number
      }
      /**
       * @deprecated
       * @description DEPRECATED. Populate dbtCloud instead.
       */
      executionUrl?: string
      /**
       * @deprecated
       * @description DEPRECATED. Populate dbtCloud instead.
       */
      executionBody?: string
    }
    CheckOperationRead: {
      /** @enum {string} */
      status: 'succeeded' | 'failed'
      message?: string
    }
    /** Format: uuid */
    OrganizationId: string
    OrganizationIdRequestBody: {
      /** Format: uuid */
      organizationId: string
    }
    OrganizationUpdateRequestBody: {
      /** Format: uuid */
      organizationId: string
      organizationName?: string
      pba?: boolean
      orgLevelBilling?: boolean
      email?: string
    }
    OrganizationCreateRequestBody: {
      /** Format: uuid */
      userId: string
      organizationName: string
      email?: string
      pba?: boolean
      orgLevelBilling?: boolean
    }
    OrganizationRead: {
      /** Format: uuid */
      organizationId: string
      organizationName: string
      email: string
      pba: boolean
      orgLevelBilling: boolean
      ssoRealm?: string
    }
    OrganizationReadList: {
      organizations: components['schemas']['OrganizationRead'][]
    }
    ListOrganizationsByUserRequestBody: {
      /** Format: uuid */
      userId: string
      pagination?: components['schemas']['Pagination']
      nameContains?: string
    }
    OrganizationUserReadList: {
      users: components['schemas']['OrganizationUserRead'][]
    }
    OrganizationUserRead: {
      /** @description Caption name for the user */
      name?: string
      userId: components['schemas']['UserId']
      /** Format: email */
      email: string
      /** Format: uuid */
      permissionId: string
      permissionType: components['schemas']['PermissionType']
      organizationId: components['schemas']['OrganizationId']
    }
    PermissionIdRequestBody: {
      /** Format: uuid */
      permissionId: string
    }
    PermissionCreate: {
      /**
       * Format: uuid
       * @description This is a temporary and optional field just for dual write purpose during the data migration.
       */
      permissionId?: string
      permissionType: components['schemas']['PermissionType']
      userId: components['schemas']['UserId']
      workspaceId?: components['schemas']['WorkspaceId']
      organizationId?: components['schemas']['OrganizationId']
    }
    PermissionDeleteUserFromWorkspaceRequestBody: {
      /**
       * Format: uuid
       * @description The user ID for which to remove workspace permissions
       */
      userIdToRemove: string
      /**
       * Format: uuid
       * @description The workspace ID from which to remove all workspace-level permissions for the indicated user
       */
      workspaceId: string
    }
    PermissionRead: {
      /** Format: uuid */
      permissionId: string
      permissionType: components['schemas']['PermissionType']
      userId: components['schemas']['UserId']
      workspaceId?: components['schemas']['WorkspaceId']
      organizationId?: components['schemas']['OrganizationId']
    }
    PermissionReadList: {
      permissions: components['schemas']['PermissionRead'][]
    }
    PermissionUpdate: {
      /** Format: uuid */
      permissionId: string
      permissionType?: components['schemas']['PermissionType']
    }
    /**
     * @description Describes what actions/endpoints the permission entitles to
     * @enum {string}
     */
    PermissionType:
      | 'instance_admin'
      | 'organization_admin'
      | 'organization_editor'
      | 'organization_reader'
      | 'organization_member'
      | 'workspace_owner'
      | 'workspace_admin'
      | 'workspace_editor'
      | 'workspace_reader'
    /**
     * @description Subset of `PermissionType` (removing `instance_admin`), could be used in public-api.
     * @enum {string}
     */
    PublicPermissionType:
      | 'organization_admin'
      | 'organization_editor'
      | 'organization_reader'
      | 'organization_member'
      | 'workspace_admin'
      | 'workspace_editor'
      | 'workspace_reader'
    PermissionCheckRequest: {
      permissionType: components['schemas']['PermissionType']
      userId: components['schemas']['UserId']
      workspaceId?: components['schemas']['WorkspaceId']
      organizationId?: components['schemas']['OrganizationId']
    }
    PermissionsCheckMultipleWorkspacesRequest: {
      permissionType: components['schemas']['PermissionType']
      userId: components['schemas']['UserId']
      workspaceIds?: components['schemas']['WorkspaceId'][]
    }
    PermissionCheckRead: {
      /** @enum {string} */
      status: 'succeeded' | 'failed'
      message?: string
    }
    /**
     * Format: uuid
     * @description Internal Airbyte user ID
     */
    UserId: string
    UserIdRequestBody: {
      userId: components['schemas']['UserId']
    }
    /**
     * @description Auth Provider
     * @default airbyte
     * @enum {string}
     */
    AuthProvider: 'airbyte' | 'google_identity_platform' | 'keycloak'
    /**
     * @description user status
     * @enum {string}
     */
    UserStatus: 'invited' | 'registered' | 'disabled'
    UserRead: {
      /** @description Caption name for the user */
      name?: string
      userId: components['schemas']['UserId']
      /** @description The userId from the Auth provider */
      authUserId: string
      authProvider: components['schemas']['AuthProvider']
      defaultWorkspaceId?: components['schemas']['WorkspaceId']
      status?: components['schemas']['UserStatus']
      companyName?: string
      /** Format: email */
      email: string
      news?: boolean
      /** @description UI metadata required by frontend */
      metadata: Record<string, never>
    }
    UserUpdate: {
      /** @description Caption name for the user */
      name?: string
      userId: components['schemas']['UserId']
      /** @description The userId from the Auth provider */
      authUserId?: string
      authProvider?: components['schemas']['AuthProvider']
      defaultWorkspaceId?: components['schemas']['WorkspaceId']
      status?: components['schemas']['UserStatus']
      companyName?: string
      news?: boolean
      /** @description UI metadata used in frontend */
      metadata?: Record<string, never>
    }
    UserAuthIdRequestBody: {
      authUserId: string
    }
    UserEmailRequestBody: {
      email: string
    }
    UserCreate: {
      /**
       * Format: uuid
       * @description User ID. This is a temporary and optional field just for dual write purpose during the data migration.
       */
      userId?: string
      /** @description Caption name for the user */
      name: string
      /** @description The userId from the Auth provider */
      authUserId: string
      authProvider: components['schemas']['AuthProvider']
      status?: components['schemas']['UserStatus']
      companyName?: string
      /** Format: email */
      email: string
      /** @default false */
      news?: boolean
    }
    UserGetOrCreateByAuthIdResponse: {
      userRead: components['schemas']['UserRead']
      /** @default false */
      newUserCreated?: boolean
    }
    /**
     * @description type/source of logs produced
     * @enum {string}
     */
    LogType: 'server' | 'scheduler'
    LogsRequestBody: {
      logType: components['schemas']['LogType']
    }
    /** @description A source actor catalog with the timestamp it was mostly recently updated */
    ActorCatalogWithUpdatedAt: {
      /** Format: int64 */
      updatedAt?: number
      catalog?: Record<string, never>
    }
    /** @description describes the available schema (catalog). */
    AirbyteCatalog: {
      streams: components['schemas']['AirbyteStreamAndConfiguration'][]
    }
    /** @description each stream is split in two parts; the immutable schema from source and mutable configuration for destination */
    AirbyteStreamAndConfiguration: {
      stream?: components['schemas']['AirbyteStream']
      config?: components['schemas']['AirbyteStreamConfiguration']
    }
    /** @description the immutable schema defined by the source */
    AirbyteStream: {
      /** @description Stream's name. */
      name: string
      jsonSchema?: components['schemas']['StreamJsonSchema']
      supportedSyncModes?: components['schemas']['SyncMode'][]
      /** @description If the source defines the cursor field, then any other cursor field inputs will be ignored. If it does not, either the user_provided one is used, or the default one is used as a backup. */
      sourceDefinedCursor?: boolean
      /** @description Path to the field that will be used to determine if a record is new or modified since the last sync. If not provided by the source, the end user will have to specify the comparable themselves. */
      defaultCursorField?: string[]
      /** @description If the source defines the primary key, paths to the fields that will be used as a primary key. If not provided by the source, the end user will have to specify the primary key themselves. */
      sourceDefinedPrimaryKey?: string[][]
      /** @description Optional Source-defined namespace. Airbyte streams from the same sources should have the same namespace. Currently only used by JDBC destinations to determine what schema to write to. */
      namespace?: string
    }
    /** @description Stream schema using Json Schema specs. */
    StreamJsonSchema: Record<string, never>
    /** @description the mutable part of the stream to configure the destination */
    AirbyteStreamConfiguration: {
      syncMode: components['schemas']['SyncMode']
      /** @description Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental`. Otherwise it is ignored. */
      cursorField?: string[]
      destinationSyncMode: components['schemas']['DestinationSyncMode']
      /** @description Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup`. Otherwise it is ignored. */
      primaryKey?: string[][]
      /** @description Alias name to the stream to be used in the destination */
      aliasName?: string
      /** @description If this is true, the stream is selected with all of its properties. For new connections, this considers if the stream is suggested or not */
      selected?: boolean
      /** @description Does the connector suggest that this stream be enabled by default? */
      suggested?: boolean
      /** @description Whether field selection should be enabled. If this is true, only the properties in `selectedFields` will be included. */
      fieldSelectionEnabled?: boolean
      /** @description This must be set if `fieldSelectedEnabled` is set. An empty list indicates that no properties will be included. */
      selectedFields?: components['schemas']['SelectedFields']
      /**
       * Format: int64
       * @description The minimum generation Id of the stream
       */
      minimumGenerationId?: number
      /**
       * Format: int64
       * @description Generation Id of the stream
       */
      generationId?: number
      /**
       * Format: int64
       * @description Sync id of the stream.
       */
      syncId?: number
    }
    /** @description Path to a field/column/property in a stream to be selected. For example, if the field to be selected is a database column called "foo", this will be ["foo"]. Use multiple path elements for nested schemas. */
    SelectedFieldInfo: {
      fieldPath?: string[]
    }
    /** @description Paths to the fields that will be included in the configured catalog. */
    SelectedFields: components['schemas']['SelectedFieldInfo'][]
    /** @enum {string} */
    DataType: 'string' | 'number' | 'boolean' | 'object' | 'array'
    /** Format: int64 */
    JobId: number
    /** @enum {string} */
    JobConfigType:
      | 'check_connection_source'
      | 'check_connection_destination'
      | 'discover_schema'
      | 'get_spec'
      | 'sync'
      | 'reset_connection'
      | 'refresh'
      | 'clear'
    JobCreate: {
      connectionId: components['schemas']['ConnectionId']
    }
    JobListRequestBody: {
      configTypes: components['schemas']['JobConfigType'][]
      configId?: string
      /** @description If the job with this ID exists for the specified connection, returns the number of pages of jobs necessary to include this job. Returns an empty list if this job is specified and cannot be found in this connection. */
      includingJobId?: components['schemas']['JobId']
      pagination?: components['schemas']['Pagination']
      /** @description The Job statuses you want to filter by */
      statuses?: components['schemas']['JobStatus'][]
      /**
       * Format: date-time
       * @description The start datetime to filter by
       */
      createdAtStart?: string
      /**
       * Format: date-time
       * @description The end datetime to filter by
       */
      createdAtEnd?: string
      /**
       * Format: date-time
       * @description The start datetime to filter by
       */
      updatedAtStart?: string
      /**
       * Format: date-time
       * @description The end datetime to filter by
       */
      updatedAtEnd?: string
      /**
       * @description The field to order by
       * @enum {string}
       */
      orderByField?: 'createdAt' | 'updatedAt'
      /**
       * @description The order by method
       * @enum {string}
       */
      orderByMethod?: 'ASC' | 'DESC'
    }
    JobListForWorkspacesRequestBody: {
      configTypes: components['schemas']['JobConfigType'][]
      configId?: string
      workspaceIds?: components['schemas']['WorkspaceId'][]
      pagination?: components['schemas']['Pagination']
      /** @description The Job statuses you want to filter by */
      statuses?: components['schemas']['JobStatus'][]
      /**
       * Format: date-time
       * @description The start datetime to filter by
       */
      createdAtStart?: string
      /**
       * Format: date-time
       * @description The end datetime to filter by
       */
      createdAtEnd?: string
      /**
       * Format: date-time
       * @description The start datetime to filter by
       */
      updatedAtStart?: string
      /**
       * Format: date-time
       * @description The end datetime to filter by
       */
      updatedAtEnd?: string
      /**
       * @description The field to order by
       * @enum {string}
       */
      orderByField?: 'createdAt' | 'updatedAt'
      /**
       * @description The order by method
       * @enum {string}
       */
      orderByMethod?: 'ASC' | 'DESC'
    }
    JobIdRequestBody: {
      id: components['schemas']['JobId']
    }
    JobRead: {
      id: components['schemas']['JobId']
      configType: components['schemas']['JobConfigType']
      configId: string
      enabledStreams?: components['schemas']['StreamDescriptor'][]
      /** Format: int64 */
      createdAt: number
      /** Format: int64 */
      updatedAt: number
      /** Format: int64 */
      startedAt?: number
      status: components['schemas']['JobStatus']
      resetConfig?: components['schemas']['ResetConfig']
      aggregatedStats?: components['schemas']['JobAggregatedStats']
      streamAggregatedStats?: components['schemas']['StreamAggregatedStats']
    }
    JobAggregatedStats: {
      /** Format: int64 */
      recordsEmitted: number
      /** Format: int64 */
      bytesEmitted: number
      /** Format: int64 */
      recordsCommitted: number
      /** Format: int64 */
      bytesCommitted: number
    }
    StreamAggregatedStats: components['schemas']['StreamStats'][]
    StreamStats: {
      streamName: string
      streamNamespace?: string
      /** Format: int64 */
      recordsEmitted: number
      /** Format: int64 */
      bytesEmitted: number
      /** Format: int64 */
      recordsCommitted: number
      /** Format: int64 */
      bytesCommitted: number
      wasBackfilled?: boolean
    }
    SyncInput: {
      jobId: components['schemas']['JobId']
      attemptNumber: components['schemas']['AttemptNumber']
    }
    CheckInput: {
      jobId: components['schemas']['JobId']
      attemptNumber: components['schemas']['AttemptNumber']
    }
    /** @description This return a json blob aimed to be used as a JobInput. It is serialized by the JobInput java class and should be deserialized into it. */
    SyncJobInputRead: unknown
    /** @description contains information about how a reset was configured. only populated if the job was a reset. */
    ResetConfig: {
      streamsToReset?: components['schemas']['StreamDescriptor'][]
    }
    StreamDescriptor: {
      name: string
      namespace?: string
    }
    JobDebugRead: {
      id: components['schemas']['JobId']
      configType: components['schemas']['JobConfigType']
      configId: string
      status: components['schemas']['JobStatus']
      airbyteVersion: string
      sourceDefinition: components['schemas']['SourceDefinitionRead']
      destinationDefinition: components['schemas']['DestinationDefinitionRead']
    }
    WorkflowStateRead: {
      running: boolean
    }
    JobWithAttemptsRead: {
      job?: components['schemas']['JobRead']
      attempts?: components['schemas']['AttemptRead'][]
    }
    /**
     * Format: int64
     * @description epoch time of the latest sync job. null if no sync job has taken place.
     */
    JobCreatedAt: number
    /** @enum {string} */
    JobStatus:
      | 'pending'
      | 'running'
      | 'incomplete'
      | 'failed'
      | 'succeeded'
      | 'cancelled'
    AttemptRead: {
      /** Format: int64 */
      id: number
      status: components['schemas']['AttemptStatus']
      /** Format: int64 */
      createdAt: number
      /** Format: int64 */
      updatedAt: number
      /** Format: int64 */
      endedAt?: number
      /** Format: int64 */
      bytesSynced?: number
      /** Format: int64 */
      recordsSynced?: number
      totalStats?: components['schemas']['AttemptStats']
      streamStats?: components['schemas']['AttemptStreamStats'][]
      failureSummary?: components['schemas']['AttemptFailureSummary']
    }
    AttemptStats: {
      /** Format: int64 */
      recordsEmitted?: number
      /** Format: int64 */
      bytesEmitted?: number
      /** Format: int64 */
      stateMessagesEmitted?: number
      /** Format: int64 */
      bytesCommitted?: number
      /** Format: int64 */
      recordsCommitted?: number
      /** Format: int64 */
      estimatedRecords?: number
      /** Format: int64 */
      estimatedBytes?: number
    }
    AttemptStreamStats: {
      streamName: string
      streamNamespace?: string
      stats: components['schemas']['AttemptStats']
    }
    AttemptFailureSummary: {
      failures: components['schemas']['FailureReason'][]
      /** @description True if the number of committed records for this attempt was greater than 0. False if 0 records were committed. If not set, the number of committed records is unknown. */
      partialSuccess?: boolean
    }
    FailureReason: {
      failureOrigin?: components['schemas']['FailureOrigin']
      failureType?: components['schemas']['FailureType']
      externalMessage?: string
      internalMessage?: string
      stacktrace?: string
      /** @description True if it is known that retrying may succeed, e.g. for a transient failure. False if it is known that a retry will not succeed, e.g. for a configuration issue. If not set, retryable status is not well known. */
      retryable?: boolean
      /** Format: int64 */
      timestamp: number
    }
    /**
     * @description Indicates where the error originated. If not set, the origin of error is not well known.
     * @enum {string}
     */
    FailureOrigin:
      | 'source'
      | 'destination'
      | 'replication'
      | 'persistence'
      | 'normalization'
      | 'dbt'
      | 'airbyte_platform'
      | 'unknown'
    /**
     * @description Categorizes well known errors into types for programmatic handling. If not set, the type of error is not well known.
     * @enum {string}
     */
    FailureType:
      | 'config_error'
      | 'system_error'
      | 'manual_cancellation'
      | 'refresh_schema'
      | 'heartbeat_timeout'
      | 'destination_timeout'
      | 'transient_error'
    /** @enum {string} */
    AttemptStatus: 'running' | 'failed' | 'succeeded'
    JobReadList: {
      jobs: components['schemas']['JobWithAttemptsRead'][]
      /**
       * Format: int64
       * @description the total count of jobs for the specified connection
       */
      totalJobCount: number
    }
    JobInfoRead: {
      job: components['schemas']['JobRead']
      attempts: components['schemas']['AttemptInfoRead'][]
    }
    JobInfoLightRead: {
      job: components['schemas']['JobRead']
    }
    JobOptionalRead: {
      job?: components['schemas']['JobRead']
    }
    JobDebugInfoRead: {
      job: components['schemas']['JobDebugRead']
      attempts: components['schemas']['AttemptInfoRead'][]
      workflowState?: components['schemas']['WorkflowStateRead']
    }
    AttemptInfoRead: {
      attempt: components['schemas']['AttemptRead']
      logs: components['schemas']['LogRead']
    }
    LogRead: {
      logLines: string[]
    }
    SynchronousJobRead: {
      /** Format: uuid */
      id: string
      configType: components['schemas']['JobConfigType']
      /** @description only present if a config id was provided. */
      configId?: string
      /** Format: int64 */
      createdAt: number
      /** Format: int64 */
      endedAt: number
      succeeded: boolean
      /** @default false */
      connectorConfigurationUpdated?: boolean
      logs?: components['schemas']['LogRead']
      failureReason?: components['schemas']['FailureReason']
    }
    Pagination: {
      pageSize?: number
      rowOffset?: number
    }
    HealthCheckRead: {
      available: boolean
    }
    CheckConnectionRead: {
      /** @enum {string} */
      status?: 'succeeded' | 'failed'
      message?: string
      jobInfo: components['schemas']['SynchronousJobRead']
    }
    /** @description Contains the state for a connection. The stateType field identifies what type of state it is. Only the field corresponding to that type will be set, the rest will be null. If stateType=not_set, then none of the fields will be set. */
    ConnectionState: {
      stateType: components['schemas']['ConnectionStateType']
      connectionId: components['schemas']['ConnectionId']
      state?: components['schemas']['StateBlob']
      streamState?: components['schemas']['StreamState'][]
      globalState?: components['schemas']['GlobalState']
    }
    StateBlob: Record<string, never>
    StreamState: {
      streamDescriptor: components['schemas']['StreamDescriptor']
      streamState?: components['schemas']['StateBlob']
    }
    GlobalState: {
      shared_state?: components['schemas']['StateBlob']
      streamStates: components['schemas']['StreamState'][]
    }
    /** @enum {string} */
    ConnectionStateType: 'global' | 'stream' | 'legacy' | 'not_set'
    /** @description Describes the difference between two Airbyte catalogs. */
    CatalogDiff: {
      /** @description list of stream transformations. order does not matter. */
      transforms: components['schemas']['StreamTransform'][]
    }
    StreamTransform: {
      /** @enum {string} */
      transformType: 'add_stream' | 'remove_stream' | 'update_stream'
      streamDescriptor: components['schemas']['StreamDescriptor']
      updateStream?: {
        /** @description list of field transformations. order does not matter. */
        fieldTransforms: components['schemas']['FieldTransform'][]
        /** @description list of stream attribute transformations. order does not matter. */
        streamAttributeTransforms: components['schemas']['StreamAttributeTransform'][]
      }
    }
    /** @description Describes the difference in a field between two Streams. */
    FieldTransform: {
      /** @enum {string} */
      transformType: 'add_field' | 'remove_field' | 'update_field_schema'
      fieldName: components['schemas']['FieldName']
      breaking: boolean
      addField?: components['schemas']['FieldAdd']
      removeField?: components['schemas']['FieldRemove']
      updateFieldSchema?: components['schemas']['FieldSchemaUpdate']
    }
    FieldAdd: {
      schema?: components['schemas']['FieldSchema']
    }
    FieldRemove: {
      schema?: components['schemas']['FieldSchema']
    }
    FieldSchemaUpdate: {
      oldSchema: components['schemas']['FieldSchema']
      newSchema: components['schemas']['FieldSchema']
    }
    /** @description A field name is a list of strings that form the path to the field. */
    FieldName: string[]
    /** @description JSONSchema representation of the field */
    FieldSchema: Record<string, never>
    /** @description Describes the difference in an attribute between two Streams. */
    StreamAttributeTransform: {
      /** @enum {string} */
      transformType: 'update_primary_key'
      breaking: boolean
      updatePrimaryKey?: components['schemas']['StreamAttributePrimaryKeyUpdate']
    }
    StreamAttributePrimaryKeyUpdate: {
      oldPrimaryKey?: components['schemas']['FieldName'][]
      newPrimaryKey?: components['schemas']['FieldName'][]
    }
    /** @description actor definition specific resource requirements. if default is set, these are the requirements that should be set for ALL jobs run for this actor definition. it is overriden by the job type specific configurations. if not set, the platform will use defaults. these values will be overriden by configuration at the connection level. */
    ActorDefinitionResourceRequirements: {
      default?: components['schemas']['ResourceRequirements']
      jobSpecific?: components['schemas']['JobTypeResourceLimit'][]
    }
    /**
     * Format: uuid
     * @description A unique identifier for an actor definition.
     */
    ActorDefinitionId: string
    ActorDefinitionRequestBody: {
      actorDefinitionId: components['schemas']['ActorDefinitionId']
      actorType: components['schemas']['ActorType']
    }
    /**
     * Format: uuid
     * @description A unique identifier for an actor.
     */
    ActorId: string
    /** @description describes a normalization config for destination definition version */
    NormalizationDestinationDefinitionConfig: {
      /**
       * @description whether the destination definition supports normalization.
       * @default false
       */
      supported: boolean
      /** @description a field indicating the name of the repository to be used for normalization. If the value of the flag is NULL - normalization is not used. */
      normalizationRepository?: string
      /** @description a field indicating the tag of the docker repository to be used for normalization. */
      normalizationTag?: string
      /** @description a field indicating the type of integration dialect to use for normalization. */
      normalizationIntegrationType?: string
    }
    /** @description sets resource requirements for a specific job type for an actor definition. these values override the default, if both are set. */
    JobTypeResourceLimit: {
      jobType: components['schemas']['JobType']
      resourceRequirements: components['schemas']['ResourceRequirements']
    }
    /**
     * @description enum that describes the different types of jobs that the platform runs.
     * @enum {string}
     */
    JobType:
      | 'get_spec'
      | 'check_connection'
      | 'discover_schema'
      | 'sync'
      | 'reset_connection'
      | 'connection_updater'
      | 'replicate'
    /** @description optional resource requirements to run workers (blank for unbounded allocations) */
    ResourceRequirements: {
      cpu_request?: string
      cpu_limit?: string
      memory_request?: string
      memory_limit?: string
    }
    /** @enum {string} */
    DbMigrationState:
      | 'pending'
      | 'above_target'
      | 'below_baseline'
      | 'baseline'
      | 'ignored'
      | 'missing_success'
      | 'missing_failed'
      | 'success'
      | 'undone'
      | 'available'
      | 'failed'
      | 'out_of_order'
      | 'future_success'
      | 'future_failed'
      | 'outdated'
      | 'superseded'
      | 'deleted'
    DbMigrationRead: {
      migrationType: string
      migrationVersion: string
      migrationDescription: string
      migrationState?: components['schemas']['DbMigrationState']
      migratedBy?: string
      /** Format: int64 */
      migratedAt?: number
      migrationScript?: string
    }
    DbMigrationReadList: {
      migrations?: components['schemas']['DbMigrationRead'][]
    }
    DbMigrationExecutionRead: {
      initialVersion?: string
      targetVersion?: string
      executedMigrations?: components['schemas']['DbMigrationRead'][]
    }
    /** @description The values required to configure OAuth flows. The schema for this must match the `OAuthConfigSpecification.oauthUserInputFromConnectorConfigSpecification` schema. */
    OAuthConfiguration: unknown
    OAuthInputConfiguration: components['schemas']['OAuthConfiguration']
    AdvancedAuth: {
      /** @enum {string} */
      authFlowType?: 'oauth2.0' | 'oauth1.0'
      /** @description Json Path to a field in the connectorSpecification that should exist for the advanced auth to be applicable. */
      predicateKey?: string[]
      /** @description Value of the predicate_key fields for the advanced auth to be applicable. */
      predicateValue?: string
      oauthConfigSpecification?: components['schemas']['OAuthConfigSpecification']
    }
    OAuthConfigSpecification: {
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations used as input to OAuth.
       * Must be a valid non-nested JSON that refers to properties from ConnectorSpecification.connectionSpecification
       * using special annotation 'path_in_connector_config'.
       * These are input values the user is entering through the UI to authenticate to the connector, that might also shared
       * as inputs for syncing data via the connector.
       *
       * Examples:
       *
       * if no connector values is shared during oauth flow, oauth_user_input_from_connector_config_specification=[]
       * if connector values such as 'app_id' inside the top level are used to generate the API url for the oauth flow,
       *   oauth_user_input_from_connector_config_specification={
       *     app_id: {
       *       type: string
       *       path_in_connector_config: ['app_id']
       *     }
       *   }
       * if connector values such as 'info.app_id' nested inside another object are used to generate the API url for the oauth flow,
       *   oauth_user_input_from_connector_config_specification={
       *     app_id: {
       *       type: string
       *       path_in_connector_config: ['info', 'app_id']
       *     }
       *   }
       */
      oauthUserInputFromConnectorConfigSpecification?: components['schemas']['OAuthConfiguration']
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations produced by the OAuth flows as they are
       * returned by the distant OAuth APIs.
       * Must be a valid JSON describing the fields to merge back to `ConnectorSpecification.connectionSpecification`.
       * For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,
       *
       * Examples:
       *
       *     complete_oauth_output_specification={
       *       refresh_token: {
       *         type: string,
       *         path_in_connector_config: ['credentials', 'refresh_token']
       *       }
       *     }
       */
      completeOAuthOutputSpecification?: components['schemas']['OAuthConfiguration']
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations.
       * Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
       * server when completing an OAuth flow (typically exchanging an auth code for refresh token).
       *
       * Examples:
       *
       *     complete_oauth_server_input_specification={
       *       client_id: {
       *         type: string
       *       },
       *       client_secret: {
       *         type: string
       *       }
       *     }
       */
      completeOAuthServerInputSpecification?: components['schemas']['OAuthConfiguration']
      /**
       * @description OAuth specific blob. This is a Json Schema used to validate Json configurations persisted as Airbyte Server configurations that
       * also need to be merged back into the connector configuration at runtime.
       * This is a subset configuration of `complete_oauth_server_input_specification` that filters fields out to retain only the ones that
       * are necessary for the connector to function with OAuth. (some fields could be used during oauth flows but not needed afterwards, therefore
       * they would be listed in the `complete_oauth_server_input_specification` but not `complete_oauth_server_output_specification`)
       * Must be a valid non-nested JSON describing additional fields configured by the Airbyte Instance or Workspace Admins to be used by the
       * connector when using OAuth flow APIs.
       * These fields are to be merged back to `ConnectorSpecification.connectionSpecification`.
       * For each field, a special annotation `path_in_connector_config` can be specified to determine where to merge it,
       *
       * Examples:
       *
       *       complete_oauth_server_output_specification={
       *         client_id: {
       *           type: string,
       *           path_in_connector_config: ['credentials', 'client_id']
       *         },
       *         client_secret: {
       *           type: string,
       *           path_in_connector_config: ['credentials', 'client_secret']
       *         }
       *       }
       */
      completeOAuthServerOutputSpecification?: components['schemas']['OAuthConfiguration']
    }
    SourceOauthConsentRequest: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
      /** @description The url to redirect to after getting the user consent */
      redirectUrl: string
      oAuthInputConfiguration?: components['schemas']['OAuthInputConfiguration']
      sourceId?: components['schemas']['SourceId']
    }
    DestinationOauthConsentRequest: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
      /** @description The url to redirect to after getting the user consent */
      redirectUrl: string
      oAuthInputConfiguration?: components['schemas']['OAuthInputConfiguration']
      destinationId?: components['schemas']['DestinationId']
    }
    OAuthConsentRead: {
      consentUrl: string
    }
    CompleteSourceOauthRequest: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
      /** @description When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
      redirectUrl?: string
      /** @description The query parameters present in the redirect URL after a user granted consent e.g auth code */
      queryParams?: {
        [key: string]: unknown
      }
      oAuthInputConfiguration?: components['schemas']['OAuthInputConfiguration']
      /**
       * @description If set to true, returns a secret coordinate which references the stored tokens. By default, returns raw tokens.
       * @default false
       */
      returnSecretCoordinate?: boolean
      sourceId?: components['schemas']['SourceId']
    }
    RevokeSourceOauthTokensRequest: {
      workspaceId: components['schemas']['WorkspaceId']
      sourceId: components['schemas']['SourceId']
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
    }
    CompleteDestinationOAuthRequest: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      workspaceId: components['schemas']['WorkspaceId']
      /** @description When completing OAuth flow to gain an access token, some API sometimes requires to verify that the app re-send the redirectUrl that was used when consent was given. */
      redirectUrl?: string
      /** @description The query parameters present in the redirect URL after a user granted consent e.g auth code */
      queryParams?: {
        [key: string]: unknown
      }
      oAuthInputConfiguration?: components['schemas']['OAuthInputConfiguration']
      destinationId?: components['schemas']['DestinationId']
    }
    CompleteOAuthResponse: {
      request_succeeded: boolean
      request_error?: string
      auth_payload: {
        [key: string]: unknown
      }
    }
    SetInstancewideSourceOauthParamsRequestBody: {
      sourceDefinitionId: components['schemas']['SourceDefinitionId']
      params: {
        [key: string]: unknown
      }
    }
    SetInstancewideDestinationOauthParamsRequestBody: {
      destinationDefinitionId: components['schemas']['DestinationDefinitionId']
      params: {
        [key: string]: unknown
      }
    }
    WorkspaceOverrideOauthParamsRequestBody: {
      /** Format: uuid */
      definitionId: string
      params: {
        [key: string]: unknown
      }
      workspaceId: components['schemas']['WorkspaceId']
      actorType: components['schemas']['ActorType']
    }
    /** @enum {string} */
    ActorType: 'source' | 'destination'
    /** @description Summary of source and destination definitions that could be updated */
    WebBackendCheckUpdatesRead: {
      destinationDefinitions: number
      sourceDefinitions: number
    }
    WebBackendConnectionListRequestBody: {
      workspaceId: components['schemas']['WorkspaceId']
      sourceId?: components['schemas']['SourceId'][]
      destinationId?: components['schemas']['DestinationId'][]
    }
    /** @description Information about a connection that shows up in the connection list view. */
    WebBackendConnectionListItem: {
      connectionId: components['schemas']['ConnectionId']
      name: string
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status: components['schemas']['ConnectionStatus']
      source: components['schemas']['SourceSnippetRead']
      destination: components['schemas']['DestinationSnippetRead']
      latestSyncJobCreatedAt?: components['schemas']['JobCreatedAt']
      latestSyncJobStatus?: components['schemas']['JobStatus']
      isSyncing: boolean
      schemaChange: components['schemas']['SchemaChange']
    }
    WebBackendConnectionRead: {
      connectionId: components['schemas']['ConnectionId']
      name: string
      namespaceDefinition?: components['schemas']['NamespaceDefinitionType']
      /**
       * @description Used when namespaceDefinition is 'customformat'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination. */
      prefix?: string
      sourceId: components['schemas']['SourceId']
      destinationId: components['schemas']['DestinationId']
      syncCatalog: components['schemas']['AirbyteCatalog']
      schedule?: components['schemas']['ConnectionSchedule']
      scheduleType?: components['schemas']['ConnectionScheduleType']
      scheduleData?: components['schemas']['ConnectionScheduleData']
      status: components['schemas']['ConnectionStatus']
      operationIds?: components['schemas']['OperationId'][]
      source: components['schemas']['SourceRead']
      destination: components['schemas']['DestinationRead']
      operations?: components['schemas']['OperationRead'][]
      latestSyncJobCreatedAt?: components['schemas']['JobCreatedAt']
      latestSyncJobStatus?: components['schemas']['JobStatus']
      isSyncing: boolean
      resourceRequirements?: components['schemas']['ResourceRequirements']
      /** Format: uuid */
      catalogId?: string
      catalogDiff?: components['schemas']['CatalogDiff']
      geography?: components['schemas']['Geography']
      schemaChange: components['schemas']['SchemaChange']
      notifySchemaChanges: boolean
      notifySchemaChangesByEmail: boolean
      nonBreakingChangesPreference: components['schemas']['NonBreakingChangesPreference']
      /** Format: int64 */
      createdAt?: number
      backfillPreference?: components['schemas']['SchemaChangeBackfillPreference']
    }
    /** @enum {string} */
    NonBreakingChangesPreference:
      | 'ignore'
      | 'disable'
      | 'propagate_columns'
      | 'propagate_fully'
    /** @enum {string} */
    SchemaChangeBackfillPreference: 'enabled' | 'disabled'
    WebBackendConnectionReadList: {
      connections: components['schemas']['WebBackendConnectionListItem'][]
    }
    /** @enum {string} */
    SyncMode: 'full_refresh' | 'incremental'
    /** @enum {string} */
    DestinationSyncMode: 'append' | 'overwrite' | 'append_dedup'
    /**
     * Format: binary
     * @description Tarball Archive (.tar.gz) of Airbyte Configuration and Database
     */
    AirbyteArchive: string
    ImportRead: {
      /** @enum {string} */
      status: 'succeeded' | 'failed'
      reason?: string
    }
    /** Format: uuid */
    ResourceId: string
    UploadRead: {
      /** @enum {string} */
      status: 'succeeded' | 'failed'
      resourceId?: components['schemas']['ResourceId']
    }
    ImportRequestBody: {
      resourceId: components['schemas']['ResourceId']
      workspaceId: components['schemas']['WorkspaceId']
    }
    /** Format: int32 */
    AttemptNumber: number
    WorkflowId: string
    SetWorkflowInAttemptRequestBody: {
      jobId: components['schemas']['JobId']
      attemptNumber: components['schemas']['AttemptNumber']
      workflowId: components['schemas']['WorkflowId']
      /** @default */
      processingTaskQueue?: string
    }
    SaveStatsRequestBody: {
      jobId: components['schemas']['JobId']
      attemptNumber: components['schemas']['AttemptNumber']
      stats: components['schemas']['AttemptStats']
      streamStats?: components['schemas']['AttemptStreamStats'][]
      connectionId?: components['schemas']['ConnectionId']
    }
    AttemptSyncConfig: {
      sourceConfiguration: components['schemas']['SourceConfiguration']
      destinationConfiguration: components['schemas']['DestinationConfiguration']
      state?: components['schemas']['ConnectionState']
    }
    SaveAttemptSyncConfigRequestBody: {
      jobId: components['schemas']['JobId']
      attemptNumber: components['schemas']['AttemptNumber']
      syncConfig: components['schemas']['AttemptSyncConfig']
    }
    GetAttemptStatsRequestBody: {
      jobId: components['schemas']['JobId']
      attemptNumber: components['schemas']['AttemptNumber']
    }
    InternalOperationResult: {
      succeeded: boolean
    }
    DiscoverCatalogResult: {
      /** Format: uuid */
      catalogId: string
    }
    AttemptNormalizationStatusReadList: {
      attemptNormalizationStatuses?: components['schemas']['AttemptNormalizationStatusRead'][]
    }
    AttemptNormalizationStatusRead: {
      attemptNumber?: components['schemas']['AttemptNumber']
      hasRecordsCommitted?: boolean
      /** Format: int64 */
      recordsCommitted?: number
      hasNormalizationFailed?: boolean
    }
    /** Format: uuid */
    StreamStatusId: string
    /**
     * @description Values:
     *   * `PENDING` - The stream operation has been selected to run
     *   * `RUNNING` - The stream operation is running
     *   * `COMPLETE` - The stream operation ran successfully to completion
     *   * `INCOMPLETE` - The stream operation has terminated in an incomplete state.
     *   See StreamStatusIncompleteRunCause for more details.
     *   * `RATE_LIMITED` - The stream is rate limited because the source has run out of API quota.
     *
     * @enum {string}
     */
    StreamStatusRunState:
      | 'PENDING'
      | 'RUNNING'
      | 'COMPLETE'
      | 'INCOMPLETE'
      | 'RATE_LIMITED'
    /**
     * @description Values:
     *   * `FAILED` - A failure has occurred
     *   * `CANCELED` - The run has been canceled
     *
     * @enum {string}
     */
    StreamStatusIncompleteRunCause: 'FAILED' | 'CANCELED'
    /** @enum {string} */
    StreamStatusJobType: 'SYNC' | 'RESET'
    StreamStatusRateLimitedMetadata: {
      /** Format: int64 */
      quotaReset?: number
    }
    StreamStatusListRequestBody: {
      attemptNumber?: components['schemas']['AttemptNumber']
      connectionId?: components['schemas']['ConnectionId']
      jobId?: components['schemas']['JobId']
      jobType?: components['schemas']['StreamStatusJobType']
      pagination: components['schemas']['Pagination']
      streamName?: string
      streamNamespace?: string
      workspaceId: components['schemas']['WorkspaceId']
    }
    StreamStatusCreateRequestBody: {
      attemptNumber: components['schemas']['AttemptNumber']
      connectionId: components['schemas']['ConnectionId']
      jobId: components['schemas']['JobId']
      incompleteRunCause?: components['schemas']['StreamStatusIncompleteRunCause']
      jobType: components['schemas']['StreamStatusJobType']
      runState: components['schemas']['StreamStatusRunState']
      streamName: string
      streamNamespace?: string
      /** Format: int64 */
      transitionedAt: number
      workspaceId: components['schemas']['WorkspaceId']
      metadata?: components['schemas']['StreamStatusRateLimitedMetadata']
    }
    StreamStatusUpdateRequestBody: components['schemas']['StreamStatusCreateRequestBody'] & {
      id: components['schemas']['StreamStatusId']
    }
    AuthConfiguration: {
      /** @enum {string} */
      mode: 'none' | 'simple' | 'oidc'
      /** @default airbyte-webapp */
      clientId?: string
      /** @default airbyte */
      defaultRealm?: string
    }
    InstanceConfigurationResponse: {
      /** @enum {string} */
      edition: 'community' | 'pro'
      /** @description release version for the corresponding edition */
      version: string
      /** @enum {string|null} */
      licenseType?: 'pro' | 'invalid' | null
      auth: components['schemas']['AuthConfiguration']
      airbyteUrl: string
      initialSetupComplete: boolean
      /** Format: uuid */
      defaultUserId: string
      /** Format: uuid */
      defaultOrganizationId: string
      /** Format: uuid */
      defaultWorkspaceId: string
      /** @enum {string} */
      trackingStrategy: 'logging' | 'segment'
    }
    InstanceConfigurationSetupRequestBody: {
      email: string
      anonymousDataCollection: boolean
      initialSetupComplete: boolean
      displaySetupWizard: boolean
      /** @description Optional name of the user to create. Defaults to 'Default User' if not specified. */
      userName?: string
      /** @description Optional name of the organization to create. Defaults to 'Default Organization' if not specified. */
      organizationName?: string
    }
    StreamStatusRead: {
      attemptNumber: components['schemas']['AttemptNumber']
      connectionId: components['schemas']['ConnectionId']
      id: components['schemas']['StreamStatusId']
      jobId: components['schemas']['JobId']
      incompleteRunCause?: components['schemas']['StreamStatusIncompleteRunCause']
      jobType: components['schemas']['StreamStatusJobType']
      runState: components['schemas']['StreamStatusRunState']
      streamName: string
      streamNamespace?: string
      /** Format: int64 */
      transitionedAt: number
      workspaceId: components['schemas']['WorkspaceId']
      metadata?: components['schemas']['StreamStatusRateLimitedMetadata']
    }
    StreamStatusReadList: {
      streamStatuses?: components['schemas']['StreamStatusRead'][]
    }
    NotificationWebhookConfigValidationRequestBody: {
      slackConfiguration: components['schemas']['SlackNotificationConfiguration']
      notificationTrigger?: components['schemas']['NotificationTrigger']
    }
    RetryStateRead: {
      /** Format: uuid */
      id: string
      connectionId: components['schemas']['ConnectionId']
      jobId: components['schemas']['JobId']
      successiveCompleteFailures: number
      totalCompleteFailures: number
      successivePartialFailures: number
      totalPartialFailures: number
    }
    JobRetryStateRequestBody: {
      /** Format: uuid */
      id?: string
      connectionId: components['schemas']['ConnectionId']
      jobId: components['schemas']['JobId']
      successiveCompleteFailures: number
      totalCompleteFailures: number
      successivePartialFailures: number
      totalPartialFailures: number
    }
    ListWorkspacesInOrganizationRequestBody: {
      /** Format: uuid */
      organizationId: string
      pagination?: components['schemas']['Pagination']
      nameContains?: string
    }
    ListWorkspacesByUserRequestBody: {
      /** Format: uuid */
      userId: string
      pagination?: components['schemas']['Pagination']
      nameContains?: string
    }
    WorkspaceUserRead: {
      /** @description Caption name for the user */
      name?: string
      userId: components['schemas']['UserId']
      isDefaultWorkspace?: boolean
      /** Format: email */
      email: string
      /** Format: uuid */
      permissionId: string
      permissionType: components['schemas']['PermissionType']
      workspaceId: components['schemas']['WorkspaceId']
    }
    WorkspaceUserReadList: {
      users: components['schemas']['WorkspaceUserRead'][]
    }
    UserWithPermissionInfoReadList: {
      users: components['schemas']['UserWithPermissionInfoRead'][]
    }
    UserWithPermissionInfoRead: {
      /** @description Caption name for the user */
      name?: string
      userId?: components['schemas']['UserId']
      /** Format: email */
      email?: string
      /** Format: uuid */
      permissionId?: string
    }
    /**
     * @description Information summarizing a user's access to a workspace. Includes the workspace-level and/or organization-level permission
     * object that grants the user access to the workspace in question, as well as basic user information to facilitate access
     * management of users in the workspace.
     */
    WorkspaceUserAccessInfoRead: {
      userId: components['schemas']['UserId']
      /** Format: email */
      userEmail: string
      userName: string
      workspaceId: components['schemas']['WorkspaceId']
      workspacePermission?: components['schemas']['PermissionRead']
      organizationPermission?: components['schemas']['PermissionRead']
    }
    WorkspaceUserAccessInfoReadList: {
      usersWithAccess: components['schemas']['WorkspaceUserAccessInfoRead'][]
    }
    InvalidInputProperty: {
      propertyPath: string
      invalidValue?: string
      message?: string
    }
    DeploymentMetadataRead: {
      environment: string
      /** Format: uuid */
      id: string
      mode: string
      version: string
    }
    NotFoundKnownExceptionInfo: {
      id?: string
      message: string
      exceptionClassName?: string
      exceptionStack?: string[]
      rootCauseExceptionClassName?: string
      rootCauseExceptionStack?: string[]
    }
    KnownExceptionInfo: {
      message: string
      exceptionClassName?: string
      exceptionStack?: string[]
      rootCauseExceptionClassName?: string
      rootCauseExceptionStack?: string[]
    }
    InvalidInputExceptionInfo: {
      message: string
      exceptionClassName?: string
      exceptionStack?: string[]
      validationErrors: components['schemas']['InvalidInputProperty'][]
    }
    ConnectionJobRequestBody: {
      connectionId: components['schemas']['ConnectionId']
      jobId: components['schemas']['JobId']
    }
    PersistCancelJobRequestBody: {
      /** @description Attempt failure summary serialized as a raw object */
      attemptFailureSummary: Record<string, never>
      attemptNumber: components['schemas']['AttemptNumber']
      connectionId: components['schemas']['ConnectionId']
      jobId: components['schemas']['JobId']
    }
    BooleanRead: {
      value: boolean
    }
    TaskQueueNameRead: {
      /** @description Name of the temporal task queue. */
      taskQueueName: string
    }
    /** @description Object representing a secret persistence configuration create/update request */
    CreateOrUpdateSecretsPersistenceConfigRequestBody: {
      secretPersistenceType: components['schemas']['SecretPersistenceType']
      configuration: Record<string, never>
      scope: components['schemas']['ScopeType']
      /** Format: uuid */
      scopeId: string
    }
    /** @description Object representing a secret persistence configuration */
    SecretPersistenceConfig: {
      secretPersistenceType: components['schemas']['SecretPersistenceType']
      configuration: components['schemas']['SecretPersistenceConfigurationJson']
      scopeType: components['schemas']['ScopeType']
      /** Format: uuid */
      scopeId: string
    }
    /** @enum {string} */
    SecretPersistenceType: 'testing' | 'google' | 'vault' | 'aws'
    /** @description Request body for getting secret persistence config */
    SecretPersistenceConfigGetRequestBody: {
      scopeType: components['schemas']['ScopeType']
      scopeId: components['schemas']['ScopeId']
    }
    SecretPersistenceConfigurationJson: Record<string, never>
    ApplicationCreate: {
      name: string
    }
    /** Format: uuid */
    ApplicationId: string
    ApplicationIdRequestBody: {
      applicationId: components['schemas']['ApplicationId']
      includeTombstone?: boolean
    }
    ApplicationReadList: {
      applications: components['schemas']['ApplicationRead'][]
    }
    ApplicationRead: {
      id: string
      name: string
      clientId: string
      clientSecret: string
      /** Format: int64 */
      createdAt: number
    }
    ApplicationTokenRequest: {
      client_id: string
      client_secret: string
    }
    AccessToken: {
      access_token: string
    }
    UserInvitationCreateRequestBody: {
      /** Format: email */
      invitedEmail: string
      permissionType: components['schemas']['PermissionType']
      scopeType: components['schemas']['ScopeType']
      /** Format: uuid */
      scopeId: string
    }
    UserInvitationCreateResponse: {
      /** @description The created invite code, if the request resulted in a new invitation being created. */
      inviteCode?: string
      /** @description True if the request resulted in the user being directly added, without a created invitation. */
      directlyAdded?: boolean
    }
    UserInvitationListRequestBody: {
      scopeType: components['schemas']['ScopeType']
      /** Format: uuid */
      scopeId: string
    }
    UserInvitationRead: {
      /** Format: uuid */
      id: string
      inviteCode: string
      /** Format: uuid */
      inviterUserId: string
      /** Format: email */
      invitedEmail: string
      /** Format: uuid */
      scopeId: string
      scopeType: components['schemas']['ScopeType']
      permissionType: components['schemas']['PermissionType']
      status: components['schemas']['UserInvitationStatus']
      /** Format: int64 */
      createdAt: number
      /** Format: int64 */
      updatedAt: number
    }
    /** @enum {string} */
    UserInvitationStatus: 'pending' | 'accepted' | 'cancelled' | 'declined'
    InviteCodeRequestBody: {
      inviteCode: string
    }
    /**
     * Root Type for RedirectUrlResponse
     * @example {
     *   "redirectUrl": "https://example.com"
     * }
     */
    RedirectUrlResponse: {
      /** Format: url */
      redirectUrl?: string
    }
    /**
     * Root Type for JobResponse
     * @description Provides details of a single job.
     * @example {
     *   "id": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *   "status": "running",
     *   "jobType": "sync",
     *   "startTime": "2023-03-25T01:30:50Z",
     *   "duration": "PT8H6M12S"
     * }
     */
    JobResponse: {
      /** Format: int64 */
      jobId: number
      status: components['schemas']['JobStatusEnum']
      jobType: components['schemas']['JobTypeEnum']
      startTime: string
      /** Format: UUID */
      connectionId: string
      lastUpdatedAt?: string
      /** @description Duration of a sync in ISO_8601 format */
      duration?: string
      /** Format: int64 */
      bytesSynced?: number
      /** Format: int64 */
      rowsSynced?: number
    }
    /**
     * Root Type for JobsResponse
     * @example {
     *   "next": "https://api.airbyte.com/v1/jobs?limit=5&offset=10",
     *   "previous": "https://api.airbyte.com/v1/jobs?limit=5&offset=0",
     *   "data": [
     *     {
     *       "id": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *       "status": "running",
     *       "jobType": "sync",
     *       "startTime": "2023-03-25T01:30:50Z"
     *     }
     *   ]
     * }
     */
    JobsResponse: {
      previous?: string
      next?: string
      data: components['schemas']['JobResponse'][]
    }
    ConnectionCreateRequest: {
      /** @description Optional name of the connection */
      name?: string
      /** Format: uuid */
      sourceId: string
      /** Format: uuid */
      destinationId: string
      configurations?: components['schemas']['StreamConfigurations']
      schedule?: components['schemas']['AirbyteApiConnectionSchedule']
      dataResidency?: components['schemas']['GeographyEnum']
      namespaceDefinition?: components['schemas']['NamespaceDefinitionEnum']
      /**
       * @description Used when namespaceDefinition is 'custom_format'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination (ex. “airbyte_” causes “projects” => “airbyte_projects”). */
      prefix?: string
      nonBreakingSchemaUpdatesBehavior?: components['schemas']['NonBreakingSchemaUpdatesBehaviorEnum']
      status?: components['schemas']['ConnectionStatusEnum']
    }
    ConnectionPatchRequest: {
      /** @description Optional name of the connection */
      name?: string
      configurations?: components['schemas']['StreamConfigurations']
      schedule?: components['schemas']['AirbyteApiConnectionSchedule']
      dataResidency?: components['schemas']['GeographyEnumNoDefault']
      namespaceDefinition?: components['schemas']['NamespaceDefinitionEnumNoDefault']
      /**
       * @description Used when namespaceDefinition is 'custom_format'. If blank then behaves like namespaceDefinition = 'destination'. If "${SOURCE_NAMESPACE}" then behaves like namespaceDefinition = 'source'.
       * @default null
       * @example ${SOURCE_NAMESPACE}
       */
      namespaceFormat?: string
      /** @description Prefix that will be prepended to the name of each stream when it is written to the destination (ex. “airbyte_” causes “projects” => “airbyte_projects”). */
      prefix?: string
      nonBreakingSchemaUpdatesBehavior?: components['schemas']['NonBreakingSchemaUpdatesBehaviorEnumNoDefault']
      status?: components['schemas']['ConnectionStatusEnum']
    }
    /**
     * Root Type for JobCreate
     * @description Creates a new Job from the configuration provided in the request body.
     * @example {
     *   "connectionId": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *   "jobType": "sync"
     * }
     */
    JobCreateRequest: {
      /** Format: UUID */
      connectionId: string
      jobType: components['schemas']['JobTypeEnum']
    }
    /** @enum {string} */
    JobStatusEnum:
      | 'pending'
      | 'running'
      | 'incomplete'
      | 'failed'
      | 'succeeded'
      | 'cancelled'
    /**
     * @description Enum that describes the different types of jobs that the platform runs.
     * @enum {string}
     */
    JobTypeEnum: 'sync' | 'reset'
    SourceCreateRequest: {
      /** @description Name of the source e.g. dev-mysql-instance. */
      name: string
      /**
       * Format: uuid
       * @description The UUID of the connector definition. One of configuration.sourceType or definitionId must be provided.
       */
      definitionId?: string
      /** Format: uuid */
      workspaceId: string
      configuration: components['schemas']['SourceConfiguration']
      /** @description Optional secretID obtained through the  OAuth redirect flow. */
      secretId?: string
    }
    SourcePutRequest: {
      name: string
      configuration: components['schemas']['SourceConfiguration']
    }
    SourcePatchRequest: {
      /** @example My source */
      name?: string
      /** Format: uuid */
      workspaceId?: string
      configuration?: components['schemas']['SourceConfiguration']
      /** @description Optional secretID obtained through the  OAuth redirect flow. */
      secretId?: string
    }
    /**
     * Root Type for initiate-oauth-post-body
     * @example {
     *   "redirectUrl": "https://cloud.airbyte.io/v1/api/oauth/callback",
     *   "workspaceId": "871d9b60-11d1-44cb-8c92-c246d53bf87e",
     *   "destinationId": "3d93b16c-ff5f-421c-8908-5a3c82088f14"
     * }
     */
    InitiateOauthRequest: {
      /** @description The name of the source to authenticate to. Deprecated - use sourceType instead. */
      name?: string
      /** @description The name of the source to authenticate to */
      sourceType?: string
      /** @description The URL to redirect the user to with the OAuth secret stored in the secret_id query string parameter after authentication is complete. */
      redirectUrl: string
      /**
       * Format: uuid
       * @description The workspace to create the secret and eventually the full source.
       */
      workspaceId: string
      /** @description Input configuration for OAuth required by some sources. */
      oAuthInputConfiguration?: components['schemas']['OAuthInputConfiguration']
    }
    /**
     * Root Type for WorkspaceOAuthCredentials
     * @description POST body for creating/updating workspace level OAuth credentials
     */
    WorkspaceOAuthCredentialsRequest: {
      actorType: components['schemas']['ActorTypeEnum']
      /** @description The name of the source i.e. google-ads */
      name: string
      configuration: components['schemas']['OAuthCredentialsConfiguration']
    }
    /**
     * @description The configuration for this source/destination based on the OAuth section of the relevant specification.
     * @example {
     *   "credentials": {
     *     "client_id": "871d9b60-11d1-44cb-8c92-c246d53bf87e",
     *     "client_secret": "shhhhhh"
     *   }
     * }
     */
    OAuthCredentialsConfiguration: Record<string, never>
    /**
     * Root Type for ConnectionResponse
     * @description Provides details of a single connection.
     */
    ConnectionResponse: {
      /** Format: UUID */
      connectionId: string
      name: string
      /** Format: UUID */
      sourceId: string
      /** Format: UUID */
      destinationId: string
      /** Format: UUID */
      workspaceId: string
      status: components['schemas']['ConnectionStatusEnum']
      schedule: components['schemas']['ConnectionScheduleResponse']
      dataResidency: components['schemas']['GeographyEnum']
      nonBreakingSchemaUpdatesBehavior?: components['schemas']['NonBreakingSchemaUpdatesBehaviorEnum']
      namespaceDefinition?: components['schemas']['NamespaceDefinitionEnum']
      namespaceFormat?: string
      prefix?: string
      configurations: components['schemas']['StreamConfigurations']
    }
    /** @description schedule for when the the connection should run, per the schedule type */
    AirbyteApiConnectionSchedule: {
      scheduleType: components['schemas']['ScheduleTypeEnum']
      cronExpression?: string
    }
    /** @enum {string} */
    ScheduleTypeEnum: 'manual' | 'cron'
    /** @description schedule for when the the connection should run, per the schedule type */
    ConnectionScheduleResponse: {
      scheduleType: components['schemas']['ScheduleTypeWithBasicEnum']
      cronExpression?: string
      basicTiming?: string
    }
    /** @enum {string} */
    ScheduleTypeWithBasicEnum: 'manual' | 'cron' | 'basic'
    /**
     * @default auto
     * @enum {string}
     */
    GeographyEnum: 'auto' | 'us' | 'eu'
    /** @enum {string} */
    GeographyEnumNoDefault: 'auto' | 'us' | 'eu'
    /** @enum {string} */
    ConnectionStatusEnum: 'active' | 'inactive' | 'deprecated'
    /**
     * @description Define the location where the data will be stored in the destination
     * @default destination
     * @enum {string}
     */
    NamespaceDefinitionEnum: 'source' | 'destination' | 'custom_format'
    /**
     * @description Set how Airbyte handles syncs when it detects a non-breaking schema change in the source
     * @default ignore
     * @enum {string}
     */
    NonBreakingSchemaUpdatesBehaviorEnum:
      | 'ignore'
      | 'disable_connection'
      | 'propagate_columns'
      | 'propagate_fully'
    /**
     * @description Define the location where the data will be stored in the destination
     * @enum {string}
     */
    NamespaceDefinitionEnumNoDefault: 'source' | 'destination' | 'custom_format'
    /**
     * @description Set how Airbyte handles syncs when it detects a non-breaking schema change in the source
     * @enum {string}
     */
    NonBreakingSchemaUpdatesBehaviorEnumNoDefault:
      | 'ignore'
      | 'disable_connection'
      | 'propagate_columns'
      | 'propagate_fully'
    /**
     * Root Type for DestinationResponse
     * @description Provides details of a single destination.
     * @example {
     *   "destinationId": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *   "name": "Analytics Team Postgres",
     *   "destinationType": "postgres",
     *   "workspaceId": "871d9b60-11d1-44cb-8c92-c246d53bf87e"
     * }
     */
    DestinationResponse: {
      /** Format: UUID */
      destinationId: string
      name: string
      destinationType: string
      /** Format: UUID */
      workspaceId: string
      configuration: components['schemas']['DestinationConfiguration']
    }
    /**
     * Root Type for SourceResponse
     * @description Provides details of a single source.
     * @example {
     *   "sourceId": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *   "name": "Analytics Team Postgres",
     *   "sourceType": "postgres",
     *   "workspaceId": "871d9b60-11d1-44cb-8c92-c246d53bf87e"
     * }
     */
    SourceResponse: {
      /** Format: UUID */
      sourceId: string
      name: string
      sourceType: string
      /** Format: UUID */
      workspaceId: string
      configuration: components['schemas']['SourceConfiguration']
    }
    DestinationCreateRequest: {
      /** @description Name of the destination e.g. dev-mysql-instance. */
      name: string
      /**
       * Format: uuid
       * @description The UUID of the connector definition. One of configuration.destinationType or definitionId must be provided.
       */
      definitionId?: string
      /** Format: uuid */
      workspaceId: string
      configuration: components['schemas']['DestinationConfiguration']
    }
    DestinationPatchRequest: {
      name?: string
      configuration?: components['schemas']['DestinationConfiguration']
    }
    DestinationPutRequest: {
      name: string
      configuration: components['schemas']['DestinationConfiguration']
    }
    WorkspaceCreateRequest: {
      /** @description Name of the workspace */
      name: string
      /**
       * Format: uuid
       * @description ID of organization to add workspace to.
       */
      organizationId?: string
    }
    WorkspaceUpdateRequest: {
      /** @description Name of the workspace */
      name: string
    }
    /**
     * Root Type for WorkspaceResponse
     * @description Provides details of a single workspace.
     */
    WorkspaceResponse: {
      /** Format: UUID */
      workspaceId: string
      name: string
      dataResidency: components['schemas']['GeographyEnum']
    }
    /**
     * Root Type for UserResponse
     * @description Provides details of a single user.
     */
    UserResponse: {
      /** @description Name of the user */
      name?: string
      userId: components['schemas']['UserId']
      /** Format: email */
      email: string
    }
    /**
     * Root Type for UsersResponse
     * @description List/Array of multiple users
     */
    UsersResponse: {
      data: components['schemas']['UserResponse'][]
    }
    PermissionCreateRequest: {
      permissionType: components['schemas']['PublicPermissionType']
      userId: components['schemas']['UserId']
      workspaceId?: components['schemas']['WorkspaceId']
      organizationId?: components['schemas']['OrganizationId']
    }
    PermissionUpdateRequest: {
      permissionType: components['schemas']['PermissionType']
    }
    /**
     * Root Type for PermissionResponse
     * @description Provides details of a single permission.
     */
    PermissionResponse: {
      /** Format: uuid */
      permissionId: string
      permissionType: components['schemas']['PermissionType']
      userId: components['schemas']['UserId']
      workspaceId?: components['schemas']['WorkspaceId']
      organizationId?: components['schemas']['OrganizationId']
    }
    /**
     * @description Scope of a single permission, e.g. workspace, organization
     * @enum {string}
     */
    PermissionScope: 'workspace' | 'organization' | 'none'
    /**
     * Root type for PermissionResponseRead
     * @description Reformat PermissionResponse with permission scope
     */
    PermissionResponseRead: {
      /** Format: uuid */
      permissionId: string
      permissionType: components['schemas']['PermissionType']
      userId: components['schemas']['UserId']
      /** Format: uuid */
      scopeId: string
      scope: components['schemas']['PermissionScope']
    }
    /**
     * Root Type for PermissionsResponse
     * @description List/Array of multiple permissions
     */
    PermissionsResponse: {
      data: components['schemas']['PermissionResponseRead'][]
    }
    /**
     * Root Type for ConnectionsResponse
     * @example {
     *   "next": "https://api.airbyte.com/v1/connections?limit=5&offset=10",
     *   "previous": "https://api.airbyte.com/v1/connections?limit=5&offset=0",
     *   "data": [
     *     {
     *       "name": "test-connection"
     *     },
     *     {
     *       "connection_id": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826"
     *     },
     *     {
     *       "sourceId": "49237019-645d-47d4-b45b-5eddf97775ce"
     *     },
     *     {
     *       "destinationId": "al312fs-0ab1-4f72-9ed7-0b8fc27c5826"
     *     },
     *     {
     *       "schedule": {
     *         "scheduleType": "manual"
     *       }
     *     },
     *     {
     *       "status": "active"
     *     },
     *     {
     *       "dataResidency": "auto"
     *     }
     *   ]
     * }
     */
    ConnectionsResponse: {
      previous?: string
      next?: string
      /** @default [] */
      data: components['schemas']['ConnectionResponse'][]
    }
    /**
     * Root Type for SourcesResponse
     * @example {
     *   "next": "https://api.airbyte.com/v1/sources?limit=5&offset=10",
     *   "previous": "https://api.airbyte.com/v1/sources?limit=5&offset=0",
     *   "data": {
     *     "sourceId": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *     "name": "Analytics Team Postgres",
     *     "sourceType": "postgres",
     *     "workspaceId": "871d9b60-11d1-44cb-8c92-c246d53bf87e"
     *   }
     * }
     */
    SourcesResponse: {
      previous?: string
      next?: string
      data: components['schemas']['SourceResponse'][]
    }
    /**
     * Root Type for DestinationsResponse
     * @example {
     *   "next": "https://api.airbyte.com/v1/destinations?limit=5&offset=10",
     *   "previous": "https://api.airbyte.com/v1/destinations?limit=5&offset=0",
     *   "data": {
     *     "destinationId": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *     "name": "Analytics Team Postgres",
     *     "destinationType": "postgres",
     *     "workspaceId": "871d9b60-11d1-44cb-8c92-c246d53bf87e"
     *   }
     * }
     */
    DestinationsResponse: {
      previous?: string
      next?: string
      data: components['schemas']['DestinationResponse'][]
    }
    /**
     * Root Type for WorkspacesResponse
     * @example {
     *   "next": "https://api.airbyte.com/v1/workspaces?limit=5&offset=10",
     *   "previous": "https://api.airbyte.com/v1/workspaces?limit=5&offset=0",
     *   "data": {
     *     "workspaceId": "18dccc91-0ab1-4f72-9ed7-0b8fc27c5826",
     *     "name": "Acme Company",
     *     "dataResidency": "auto"
     *   }
     * }
     */
    WorkspacesResponse: {
      previous?: string
      next?: string
      data: components['schemas']['WorkspaceResponse'][]
    }
    /** @description Configurations for a single stream. */
    StreamConfiguration: {
      name: string
      syncMode?: components['schemas']['ConnectionSyncModeEnum']
      /** @description Path to the field that will be used to determine if a record is new or modified since the last sync. This field is REQUIRED if `sync_mode` is `incremental` unless there is a default. */
      cursorField?: string[]
      /** @description Paths to the fields that will be used as primary key. This field is REQUIRED if `destination_sync_mode` is `*_dedup` unless it is already supplied by the source schema. */
      primaryKey?: string[][]
      selectedFields?: components['schemas']['SelectedFields']
    }
    /** @description A list of configured stream options for a connection. */
    StreamConfigurations: {
      streams?: components['schemas']['StreamConfiguration'][]
    }
    /** @description A list of stream properties. */
    StreamPropertiesResponse: components['schemas']['StreamProperties'][]
    /** @description The stream properties associated with a connection. */
    StreamProperties: {
      streamName?: string
      syncModes?: components['schemas']['ConnectionSyncModeEnum'][]
      defaultCursorField?: string[]
      sourceDefinedCursorField?: boolean
      sourceDefinedPrimaryKey?: string[][]
      propertyFields?: string[][]
    }
    /** @enum {unknown} */
    ConnectionSyncModeEnum:
      | 'full_refresh_overwrite'
      | 'full_refresh_append'
      | 'incremental_append'
      | 'incremental_deduped_history'
    /**
     * @description Whether you're setting this override for a source or destination
     * @enum {unknown}
     */
    ActorTypeEnum: 'source' | 'destination'
  }
  responses: {
    /** @description Object with given id was not found. */
    NotFoundResponse: {
      content: {
        'application/json': components['schemas']['NotFoundKnownExceptionInfo']
      }
    }
    /** @description Input failed validation */
    InvalidInputResponse: {
      content: {
        'application/json': components['schemas']['InvalidInputExceptionInfo']
      }
    }
    /** @description Operation forbidden */
    ForbiddenResponse: {
      content: {
        'application/json': components['schemas']['KnownExceptionInfo']
      }
    }
    /** @description Exception occurred; see message for details. */
    ExceptionResponse: {
      content: {
        'application/json': components['schemas']['KnownExceptionInfo']
      }
    }
    /** @description Response from the initiate OAuth call should be an object with a single property which will be the `redirect_url`. If a user is redirected to this URL, they'll be prompted by the identity provider to authenticate. */
    InitiateOauthResponse: {
      content: {
        'application/json': unknown
      }
    }
  }
  parameters: never
  requestBodies: never
  headers: never
  pathItems: never
}

export type $defs = Record<string, never>

export type external = Record<string, never>

export interface operations {
  /** Creates a workspace */
  createWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Creates a workspace with an explicit workspace ID. This should be use in acceptance tests only. */
  createWorkspaceIfNotExist: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceCreateWithId']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Deletes a workspace */
  deleteWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all workspaces registered in the current Airbyte deployment */
  listWorkspaces: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceReadList']
        }
      }
    }
  }
  /** List all workspaces registered in the current Airbyte deployment. This function also supports searching by keyword and pagination. */
  listAllWorkspacesPaginated: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ListResourcesForWorkspacesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceReadList']
        }
      }
    }
  }
  /** List workspaces by given workspace IDs registered in the current Airbyte deployment. This function also supports pagination. */
  listWorkspacesPaginated: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ListResourcesForWorkspacesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceReadList']
        }
      }
    }
  }
  /** List workspaces under the given org id. This function also supports searching by keyword and pagination. */
  listWorkspacesInOrganization: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ListWorkspacesInOrganizationRequestBody']
      }
    }
    responses: {
      /** @description Successfully retrieved workspaces under the given org id. */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** List workspaces by a given user id. The function also supports searching by keyword and pagination. */
  listWorkspacesByUser: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ListWorkspacesByUserRequestBody']
      }
    }
    responses: {
      /** @description Successfully retrieved workspaces by given user id. */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Find workspace by ID */
  getWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Find workspace by slug */
  getWorkspaceBySlug: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SlugRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Find workspace by connection id */
  getWorkspaceByConnectionId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Find workspace by connection id including the tombstone ones */
  getWorkspaceByConnectionIdWithTombstone: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Retrieve a workspace's basic organization info that is accessible for all workspace members, regardless of organization membership. */
  getOrganizationInfo: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceOrganizationInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update workspace state */
  updateWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update workspace name */
  updateWorkspaceName: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceUpdateName']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update workspace organization */
  updateWorkspaceOrganization: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceUpdateOrganization']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update workspace feedback state */
  updateWorkspaceFeedback: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceGiveFeedback']
      }
    }
    responses: {
      /** @description The feedback state has been properly updated */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Try sending a notifications; to be deprecated */
  tryNotificationConfig: {
    requestBody: {
      content: {
        'application/json': components['schemas']['Notification']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Try sending a notifications to webhook */
  tryNotificationWebhookConfig: {
    requestBody: {
      content: {
        'application/json': components['schemas']['NotificationWebhookConfigValidationRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['NotificationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update a sourceDefinition */
  updateSourceDefinition: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['SourceDefinitionUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all the sourceDefinitions the current Airbyte deployment is configured to use */
  listSourceDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionReadList']
        }
      }
    }
  }
  /**
   * List the latest sourceDefinitions Airbyte supports
   * @description Guaranteed to retrieve the latest information on supported sources.
   */
  listLatestSourceDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionReadList']
        }
      }
    }
  }
  /** Get source */
  getSourceDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceDefinitionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete a source definition */
  deleteSourceDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceDefinitionIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all private, non-custom sourceDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
  listPrivateSourceDefinitions: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PrivateSourceDefinitionReadList']
        }
      }
    }
  }
  /** List all the sourceDefinitions the given workspace is configured to use */
  listSourceDefinitionsForWorkspace: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionReadList']
        }
      }
    }
  }
  /** Creates a custom sourceDefinition for the given workspace or organization */
  createCustomSourceDefinition: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['CustomSourceDefinitionCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a sourceDefinition that is configured for the given workspace */
  getSourceDefinitionForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceDefinitionIdWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a sourceDefinition that is configured for the given workspace or organization */
  getSourceDefinitionForScope: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionIdWithScope']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** grant a private, non-custom sourceDefinition to a given workspace or organization */
  grantSourceDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionIdWithScope']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PrivateSourceDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** revoke a grant to a private, non-custom sourceDefinition from a given workspace or organization */
  revokeSourceDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionIdWithScope']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get actor definition version for a source. */
  getActorDefinitionVersionForSourceId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ActorDefinitionVersionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Get specification for a SourceDefinition. */
  getSourceDefinitionSpecification: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceDefinitionIdWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionSpecificationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get specification for a source. */
  getSpecificationForSourceId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionSpecificationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Resolve an actor definition version by version tag. */
  resolveActorDefinitionVersionByTag: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ResolveActorDefinitionVersionRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ResolveActorDefinitionVersionResponse']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Create a declarative manifest to be used by the specified source definition */
  createDeclarativeSourceDefinitionManifest: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DeclarativeSourceDefinitionCreateManifestRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      201: {
        content: never
      }
      /** @description Definition is not declarative source */
      400: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      /** @description Version already exists for definition id */
      409: {
        content: never
      }
    }
  }
  /** Update the declarative manifest version for a source */
  updateDeclarativeManifestVersion: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UpdateActiveManifestRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** List all available declarative manifest versions of a declarative source definition */
  listDeclarativeManifests: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ListDeclarativeManifestsRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DeclarativeManifestsReadList']
        }
      }
      /** @description Definition is not declarative source */
      400: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Create new connector builder project */
  createConnectorBuilderProject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorBuilderProjectWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      201: {
        content: {
          'application/json': components['schemas']['ConnectorBuilderProjectIdWithWorkspaceId']
        }
      }
    }
  }
  /** Publish a connector to the workspace */
  publishConnectorBuilderProject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorBuilderPublishRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDefinitionIdBody']
        }
      }
    }
  }
  /** Update connector builder project */
  updateConnectorBuilderProject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ExistingConnectorBuilderProjectWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
    }
  }
  /** Deletes connector builder project */
  deleteConnectorBuilderProject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorBuilderProjectIdWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
    }
  }
  /** List connector builder projects for workspace */
  listConnectorBuilderProjects: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectorBuilderProjectReadList']
        }
      }
    }
  }
  /** Get a connector builder project with draft manifest */
  getConnectorBuilderProject: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorBuilderProjectIdWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectorBuilderProjectRead']
        }
      }
    }
  }
  /** Submit a set of testing values to persist for a connector builder project */
  updateConnectorBuilderProjectTestingValues: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorBuilderProjectTestingValuesUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectorBuilderProjectTestingValues']
        }
      }
    }
  }
  /** Reads the target stream of the connector builder project using the persisted testing values */
  readConnectorBuilderProjectStream: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorBuilderProjectStreamReadRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectorBuilderProjectStreamRead']
        }
      }
    }
  }
  /** Get the documentation for a connector */
  getConnectorDocumentation: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectorDocumentationRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectorDocumentationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create a source */
  createSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update a source */
  updateSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Partially update a source */
  partialUpdateSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PartialSourceUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Upgrade a source to the latest version */
  upgradeSourceVersion: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /**
   * List sources for workspace
   * @description List sources for workspace. Does not return deleted sources.
   */
  listSourcesForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * List sources for workspace
   * @description List sources for workspace. Does not return deleted sources. Paginated.
   */
  listSourcesForWorkspacePaginated: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ListResourcesForWorkspacesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get source */
  getSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get most recent ActorCatalog for source */
  getMostRecentSourceActorCatalog: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ActorCatalogWithUpdatedAt']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Search sources */
  searchSources: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceSearch']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceReadList']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Clone source */
  cloneSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceCloneRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete a source */
  deleteSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Check connection to the source */
  checkConnectionToSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Check connection for a proposed update to a source */
  checkConnectionToSourceForUpdate: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Discover the schema catalog of the source */
  discoverSchemaForSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceDiscoverSchemaRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDiscoverSchemaRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Auto propagate the change on a catalog to a catalog saved in the DB. It will fetch all the connections linked to a source id and apply the provided diff to their catalog. */
  applySchemaChangeForSource: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceAutoPropagateChange']
      }
    }
    responses: {
      /** @description The schema was properly auto propagate */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Should only called from worker, to write result from discover activity back to DB. */
  writeDiscoverCatalogResult: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceDiscoverSchemaWriteRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['DiscoverCatalogResult']
        }
      }
    }
  }
  /** Update destinationDefinition */
  updateDestinationDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationDefinitionUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all the destinationDefinitions the current Airbyte deployment is configured to use */
  listDestinationDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionReadList']
        }
      }
    }
  }
  /**
   * List the latest destinationDefinitions Airbyte supports
   * @description Guaranteed to retrieve the latest information on supported destinations.
   */
  listLatestDestinationDefinitions: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionReadList']
        }
      }
    }
  }
  /** Get destinationDefinition */
  getDestinationDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationDefinitionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete a destination definition */
  deleteDestinationDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationDefinitionIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all private, non-custom destinationDefinitions, and for each indicate whether the given workspace has a grant for using the definition. Used by admins to view and modify a given workspace's grants. */
  listPrivateDestinationDefinitions: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PrivateDestinationDefinitionReadList']
        }
      }
    }
  }
  /** List all the destinationDefinitions the given workspace is configured to use */
  listDestinationDefinitionsForWorkspace: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionReadList']
        }
      }
    }
  }
  /** Creates a custom destinationDefinition for the given workspace */
  createCustomDestinationDefinition: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['CustomDestinationDefinitionCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a destinationDefinition that is configured for the given workspace */
  getDestinationDefinitionForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationDefinitionIdWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a destinationDefinition that is configured for the given scope */
  getDestinationDefinitionForScope: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionIdWithScope']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** grant a private, non-custom destinationDefinition to a given workspace or organization */
  grantDestinationDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionIdWithScope']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PrivateDestinationDefinitionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** revoke a grant to a private, non-custom destinationDefinition from a given workspace or organization */
  revokeDestinationDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionIdWithScope']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get actor definition version for a destination. */
  getActorDefinitionVersionForDestinationId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ActorDefinitionVersionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Get specification for a destinationDefinition */
  getDestinationDefinitionSpecification: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationDefinitionIdWithWorkspaceId']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionSpecificationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get specification for a destination */
  getSpecificationForDestinationId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationDefinitionSpecificationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create a destination */
  createDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update a destination */
  updateDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update a destination partially */
  partialUpdateDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PartialDestinationUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Upgrade a destination to the latest version */
  upgradeDestinationVersion: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** List configured destinations for a workspace */
  listDestinationsForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List configured destinations for a workspace. Pginated */
  listDestinationsForWorkspacesPaginated: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ListResourcesForWorkspacesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get configured destination */
  getDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Search destinations */
  searchDestinations: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationSearch']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationReadList']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Check connection to the destination */
  checkConnectionToDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Check connection for a proposed update to a destination */
  checkConnectionToDestinationForUpdate: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete the destination */
  deleteDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Clone destination */
  cloneDestination: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationCloneRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create a connection between a source and a destination */
  createConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Update a connection
   * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
   * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
   * with the catalog from the request. This means that to modify a single stream, the entire new catalog
   * containing the updated stream needs to be sent.
   */
  updateConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Returns all connections for a workspace.
   * @description List connections for workspace. Does not return deleted connections.
   */
  listConnectionsForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Returns all connections for a workspace. Paginated.
   * @description List connections for workspace. Does not return deleted connections. Paginated.
   */
  listConnectionsForWorkspacesPaginated: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ListConnectionsForWorkspacesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Returns all connections for a workspace, including deleted connections.
   * @description List connections for workspace, including deleted connections.
   */
  listAllConnectionsForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get the status of multiple connections */
  getConnectionStatuses: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStatusesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionStatusesRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get progress information of the current sync of a connection */
  getConnectionSyncProgress: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionSyncProgressRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get the uptime history of a connection */
  getConnectionUptimeHistory: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionUptimeHistoryRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionUptimeHistoryRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get the data history of a connection */
  getConnectionDataHistory: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionDataHistoryRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionUptimeHistoryRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get the history of a connection */
  getConnectionStreamHistory: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStreamHistoryRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionStreamHistoryRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a connection */
  getConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a connection for a given jobId */
  getConnectionForJob: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionAndJobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all connections that use the provided actor definition */
  listConnectionsByActorDefinition: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ActorDefinitionRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Auto propagate the change on a catalog to a catalog saved in the DB for the given connection. */
  applySchemaChangeForConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionAutoPropagateSchemaChange']
      }
    }
    responses: {
      /** @description The schema was properly auto propagated */
      204: {
        content: {
          'application/json': components['schemas']['ConnectionAutoPropagateResult']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Fetch the current state for a connection. */
  getState: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionState']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create or update the state for a connection. */
  createOrUpdateState: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStateCreateOrUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionState']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create or update the state for a connection. Throws error if a sync is currently running when this is called. */
  createOrUpdateStateSafe: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStateCreateOrUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionState']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
      423: components['responses']['ExceptionResponse']
    }
  }
  /** Search connections */
  searchConnections: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionSearch']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionReadList']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete a connection */
  deleteConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Trigger a manual sync of the connection */
  syncConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Reset the data for the connection. Deletes data generated by the connection in the destination. Resets any cursors back to initial state. */
  resetConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Clear the data for the connection. Deletes data generated by the connection in the destination. Clear any cursors back to initial state. */
  clearConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Sets connection to inactive if it has met any of the auto-disable conditions (i.e. it hits the max number of consecutive job failures or if it hits the max number of days with only failed jobs). Additionally, notifications will be sent if a connection is disabled or warned if it has reached halfway to disable limits. This endpoint is only able to inactivate connections with more than one non-cancelled job. */
  autoDisableConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Clear the data for a specific stream in the connection. Deletes data generated by the stream in the destination. Clear any cursors back to initial state. */
  clearConnectionStream: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStreamRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Reset the data for a specific stream in the connection. Deletes data generated by the stream in the destination. Resets any cursors back to initial state. */
  resetConnectionStream: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStreamRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** refresh the data for specific streams in the connection. If no stream is specify or the list of stream is empy, all the streams will be refreshed. Resets any cursors back to initial state. */
  refreshConnectionStream: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionStreamRefreshRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['BooleanRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Gets the string task queue name for a connection and job type. */
  getTaskQueueName: {
    requestBody: {
      content: {
        'application/json': {
          connectionId: components['schemas']['ConnectionId']
          /** @description Raw stringified name of the TemporalJobType. */
          temporalJobType: string
        }
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['TaskQueueNameRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Check if an operation to be created is valid */
  checkOperation: {
    requestBody: {
      content: {
        'application/json': components['schemas']['OperatorConfiguration']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckOperationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create an operation to be applied as part of a connection pipeline */
  createOperation: {
    requestBody: {
      content: {
        'application/json': components['schemas']['OperationCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['OperationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update an operation */
  updateOperation: {
    requestBody: {
      content: {
        'application/json': components['schemas']['OperationUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['OperationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Returns all operations for a connection.
   * @description List operations for connection.
   */
  listOperationsForConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['OperationReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Returns an operation */
  getOperation: {
    requestBody: {
      content: {
        'application/json': components['schemas']['OperationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['OperationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete an operation */
  deleteOperation: {
    requestBody: {
      content: {
        'application/json': components['schemas']['OperationIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Run check connection for a given source configuration */
  executeSourceCheckConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceCoreConfig']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckConnectionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Run discover schema for a given source a source configuration */
  executeSourceDiscoverSchema: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceCoreConfig']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceDiscoverSchemaRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Run check connection for a given destination configuration */
  executeDestinationCheckConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationCoreConfig']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CheckConnectionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Sets instancewide variables to be used for the oauth flow when creating this source. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
  setInstancewideSourceOauthParams: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SetInstancewideSourceOauthParamsRequestBody']
      }
    }
    responses: {
      /** @description Successful */
      200: {
        content: never
      }
      400: components['responses']['ExceptionResponse']
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Given a source connector definition ID, return the URL to the consent screen where to redirect the user to. */
  getSourceOAuthConsent: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SourceOauthConsentRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['OAuthConsentRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Given a source def ID generate an access/refresh token etc. */
  completeSourceOAuth: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteSourceOauthRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CompleteOAuthResponse']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Given a source definition ID and workspace ID revoke access/refresh token etc. */
  revokeSourceOAuthTokens: {
    requestBody: {
      content: {
        'application/json': components['schemas']['RevokeSourceOauthTokensRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: never
      }
      400: components['responses']['ExceptionResponse']
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Given a destination connector definition ID, return the URL to the consent screen where to redirect the user to. */
  getDestinationOAuthConsent: {
    requestBody: {
      content: {
        'application/json': components['schemas']['DestinationOauthConsentRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['OAuthConsentRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Given a destination def ID generate an access/refresh token etc. */
  completeDestinationOAuth: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CompleteDestinationOAuthRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['CompleteOAuthResponse']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Sets instancewide variables to be used for the oauth flow when creating this destination. When set, these variables will be injected into a connector's configuration before any interaction with the connector image itself. This enables running oauth flows with consistent variables e.g: the company's Google Ads developer_token, client_id, and client_secret without the user having to know about these variables. */
  setInstancewideDestinationOauthParams: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SetInstancewideDestinationOauthParamsRequestBody']
      }
    }
    responses: {
      /** @description Successful */
      200: {
        content: never
      }
      400: components['responses']['ExceptionResponse']
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Returns a summary of source and destination definitions that could be updated. */
  webBackendCheckUpdates: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendCheckUpdatesRead']
        }
      }
    }
  }
  /** Returns all non-deleted connections for a workspace. */
  webBackendListConnectionsForWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WebBackendConnectionListRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendConnectionReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a connection */
  webBackendGetConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WebBackendConnectionRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendConnectionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create a connection */
  webBackendCreateConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WebBackendConnectionCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendConnectionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Update a connection
   * @description Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
   * Any operations that lack an ID will be created. Then, the newly created operationId will be applied to the
   * connection along with the rest of the operationIds in the request body.
   * Apply a patch-style update to a connection. Only fields present on the update request body will be updated.
   * Note that if a catalog is present in the request body, the connection's entire catalog will be replaced
   * with the catalog from the request. This means that to modify a single stream, the entire new catalog
   * containing the updated stream needs to be sent.
   */
  webBackendUpdateConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WebBackendConnectionUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendConnectionRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Fetch the current state type for a connection. */
  getStateType: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionStateType']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Returns the current state of a workspace */
  webBackendGetWorkspaceState: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['WebBackendWorkspaceState']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendWorkspaceStateResult']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Returns available geographies can be selected to run data syncs in a particular geography.
   * The 'auto' entry indicates that the sync will be automatically assigned to a geography according
   * to the platform default behavior. Entries other than 'auto' are two-letter country codes that
   * follow the ISO 3166-1 alpha-2 standard.
   *
   * @description Returns all available geographies in which a data sync can run.
   */
  webBackendListGeographies: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WebBackendGeographiesListResult']
        }
      }
    }
  }
  /** Creates a new job for a given connection. If a job is already running for the connection, it will be stopped and a new job will be created. */
  createJob: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** For worker to mark an attempt as successful. */
  jobSuccessWithAttemptNumber: {
    requestBody: {
      content: {
        'application/json': {
          jobId: components['schemas']['JobId']
          attemptNumber: components['schemas']['AttemptNumber']
          connectionId: components['schemas']['ConnectionId']
          standardSyncOutput: Record<string, never>
        }
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
    }
  }
  /** Returns recent jobs for a connection. Jobs are returned in descending order by createdAt. */
  listJobsFor: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobListRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Returns recent jobs for a connection. Jobs are returned in descending order by createdAt. */
  listJobsForWorkspaces: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobListForWorkspacesRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get information about a job */
  getJobInfo: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  getLastReplicationJob: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobOptionalRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get information about a job excluding logs */
  getJobInfoWithoutLogs: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get information about a job excluding attempt info and logs */
  getJobInfoLight: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoLightRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Cancels a job */
  cancelJob: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Gets all information needed to debug this job */
  getJobDebugInfo: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['JobDebugInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get normalization status to determine if we can bypass normalization phase */
  getAttemptNormalizationStatusesForJob: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['AttemptNormalizationStatusReadList']
        }
      }
    }
  }
  /** Get the job input in order to be able to start a synchronization. */
  getJobInput: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SyncInput']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SyncJobInputRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Get the check job input */
  getCheckInput: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CheckInput']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SyncJobInputRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Fails all non-terminal jobs for a connection */
  failNonTerminalJobs: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
    }
  }
  /** For worker to report when a job starts. */
  reportJobStart: {
    requestBody: {
      content: {
        'application/json': {
          jobId: components['schemas']['JobId']
          connectionId: components['schemas']['ConnectionId']
        }
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
    }
  }
  /** Marks a job as failed */
  jobFailure: {
    requestBody: {
      content: {
        'application/json': {
          jobId: components['schemas']['JobId']
          attemptNumber: components['schemas']['AttemptNumber']
          connectionId: components['schemas']['ConnectionId']
          /** @description Reason of the failure */
          reason: string
        }
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
    }
  }
  /** Deletes all stream reset records for the specified job */
  deleteStreamResetRecordsForJob: {
    requestBody: {
      content: {
        'application/json': {
          connectionId: components['schemas']['ConnectionId']
          jobId: components['schemas']['JobId']
        }
      }
    }
    responses: {
      /** @description Successfully delete stream reset records for job */
      204: {
        content: never
      }
    }
  }
  /** Creates an Airbyte user */
  createUser: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['UserRead']
        }
      }
      /** @description Version already exists for definition id */
      409: components['responses']['ExceptionResponse']
    }
  }
  /** Find Airbyte user by internal user ID */
  getUser: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['UserRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Find Airbyte user by auth id */
  getUserByAuthId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserAuthIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['UserRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Find Airbyte user by email */
  getUserByEmail: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserEmailRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['UserRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Find Airbyte user by auth id. If not existed, will create a user. */
  getOrCreateUserByAuthId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserAuthIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['UserGetOrCreateByAuthIdResponse']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update user state */
  updateUser: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['UserRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Deletes a user */
  deleteUser: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all users in a workspace */
  listUsersInWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceUserReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List user access info for a particular workspace. */
  listAccessInfoByWorkspaceId: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceUserAccessInfoReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List all users with permissions of the given org */
  listUsersInOrganization: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['OrganizationIdRequestBody']
      }
    }
    responses: {
      /** @description Successfully retrieved users under the given org id. */
      200: {
        content: {
          'application/json': components['schemas']['OrganizationUserReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** List all users with instance admin permissions. Only instance admin has permission to call this. */
  listInstanceAdminUsers: {
    responses: {
      /** @description List all instance admin users. */
      200: {
        content: {
          'application/json': components['schemas']['UserWithPermissionInfoReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Creates a permission resource */
  createPermission: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PermissionRead']
        }
      }
      422: components['responses']['ExceptionResponse']
    }
  }
  /** Find a permission by ID */
  getPermission: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PermissionRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Check permissions for user */
  checkPermissions: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionCheckRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PermissionCheckRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Check permissions for user across workspaces */
  checkPermissionsAcrossMultipleWorkspaces: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionsCheckMultipleWorkspacesRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PermissionCheckRead']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Updates a permission resource */
  updatePermission: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionUpdate']
      }
    }
    responses: {
      /** @description Successful operation */
      204: {
        content: never
      }
      403: components['responses']['ForbiddenResponse']
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get secrets persistence config */
  getSecretsPersistenceConfig: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SecretPersistenceConfigGetRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SecretPersistenceConfig']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create or update secrets persistence config */
  createOrUpdateSecretsPersistenceConfig: {
    requestBody: {
      content: {
        'application/json': components['schemas']['CreateOrUpdateSecretsPersistenceConfigRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: never
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Deletes a permission resource */
  deletePermission: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionIdRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      403: components['responses']['ForbiddenResponse']
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Deletes all workspace-level permissions for a particular user and workspace */
  deleteUserFromWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionDeleteUserFromWorkspaceRequestBody']
      }
    }
    responses: {
      /** @description The resource was deleted successfully. */
      204: {
        content: never
      }
      403: components['responses']['ForbiddenResponse']
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** List permissions a user has access to */
  listPermissionsByUser: {
    requestBody: {
      content: {
        'application/json': components['schemas']['UserIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PermissionReadList']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Health Check */
  getHealthCheck: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['HealthCheckRead']
        }
      }
    }
  }
  /** Returns the openapi specification */
  getOpenApiSpec: {
    responses: {
      /** @description Returns the openapi specification file */
      200: {
        content: {
          'text/plain': string
        }
      }
    }
  }
  /** For worker to create a new attempt number. */
  createNewAttemptNumber: {
    requestBody: {
      content: {
        'application/json': {
          jobId: components['schemas']['JobId']
        }
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': {
            attemptNumber: components['schemas']['AttemptNumber']
          }
        }
      }
    }
  }
  /** For worker to register the workflow id in attempt. */
  setWorkflowInAttempt: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SetWorkflowInAttemptRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
    }
  }
  /** For worker to set sync stats of a running attempt. */
  saveStats: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveStatsRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
    }
  }
  /** For worker to save the AttemptSyncConfig for an attempt. */
  saveSyncConfig: {
    requestBody: {
      content: {
        'application/json': components['schemas']['SaveAttemptSyncConfigRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['InternalOperationResult']
        }
      }
    }
  }
  /** Fails an attempt with a failure summary and if provided a sync output. */
  failAttempt: {
    requestBody: {
      content: {
        'application/json': {
          jobId: components['schemas']['JobId']
          attemptNumber: components['schemas']['AttemptNumber']
          /** @description Attempt failure summary serialized as a raw object */
          failureSummary?: Record<string, never>
          /** @description Sync output serialized as a raw object */
          standardSyncOutput?: Record<string, never>
        }
      }
    }
    responses: {
      /** @description Successfully failed attempt */
      204: {
        content: never
      }
    }
  }
  /** For retrieving combined stats for a single attempt */
  getAttemptCombinedStats: {
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAttemptStatsRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['AttemptStats']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Retrieves an attempt with logs for a job and attempt number. */
  getAttemptForJob: {
    requestBody: {
      content: {
        'application/json': components['schemas']['GetAttemptStatsRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['AttemptInfoRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Gets a list of stream statuses filtered by parameters (with AND semantics). */
  getStreamStatuses: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['StreamStatusListRequestBody']
      }
    }
    responses: {
      /** @description Successfully queried stream statuses. */
      200: {
        content: {
          'application/json': components['schemas']['StreamStatusReadList']
        }
      }
    }
  }
  /** Gets a list of the latest stream status for each stream and run state for a connection. */
  getStreamStatusesByRunState: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ConnectionIdRequestBody']
      }
    }
    responses: {
      /** @description Successfully queried stream statuses. */
      200: {
        content: {
          'application/json': components['schemas']['StreamStatusReadList']
        }
      }
    }
  }
  /** Creates a stream status. */
  createStreamStatus: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['StreamStatusCreateRequestBody']
      }
    }
    responses: {
      /** @description Successfully created stream status. */
      201: {
        content: {
          'application/json': components['schemas']['StreamStatusRead']
        }
      }
    }
  }
  /** Updates a stream status. */
  updateStreamStatus: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['StreamStatusUpdateRequestBody']
      }
    }
    responses: {
      /** @description Successfully updated stream status. */
      200: {
        content: {
          'application/json': components['schemas']['StreamStatusRead']
        }
      }
      /** @description Successfully created stream status. */
      201: {
        content: {
          'application/json': components['schemas']['StreamStatusRead']
        }
      }
    }
  }
  /** Get instance configuration */
  getInstanceConfiguration: {
    responses: {
      /** @description Successfully returned instance configuration. */
      200: {
        content: {
          'application/json': components['schemas']['InstanceConfigurationResponse']
        }
      }
      /** @description Fetching instance configuration failed. */
      401: {
        content: never
      }
    }
  }
  /** Setup an instance with user and organization information. */
  setupInstanceConfiguration: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['InstanceConfigurationSetupRequestBody']
      }
    }
    responses: {
      /** @description Successfully setup instance. */
      200: {
        content: {
          'application/json': components['schemas']['InstanceConfigurationResponse']
        }
      }
      /** @description Instance setup failed. */
      401: {
        content: never
      }
    }
  }
  /** Creates or updates a retry state for a job. */
  createOrUpdate: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['JobRetryStateRequestBody']
      }
    }
    responses: {
      /** @description Successfully put retry state. */
      204: {
        content: never
      }
    }
  }
  /** Gets a retry state. */
  get: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['JobIdRequestBody']
      }
    }
    responses: {
      /** @description Successfully retrieved retry state for a job. */
      200: {
        content: {
          'application/json': components['schemas']['RetryStateRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Returns whether the job preceding the specified job succeeded */
  didPreviousJobSucceed: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionJobRequestBody']
      }
    }
    responses: {
      /** @description Successful Operation */
      200: {
        content: {
          'application/json': components['schemas']['BooleanRead']
        }
      }
    }
  }
  /** Persists the cancellation of a job and kicks off any post processing (e.g notifications). */
  persistJobCancellation: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['PersistCancelJobRequestBody']
      }
    }
    responses: {
      /** @description Successfully persisted the job cancellation. */
      204: {
        content: never
      }
    }
  }
  /** Get an organization info */
  getOrganization: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['OrganizationIdRequestBody']
      }
    }
    responses: {
      /** @description Successfully retrieved organization info. */
      200: {
        content: {
          'application/json': components['schemas']['OrganizationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Create an organization */
  createOrganization: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['OrganizationCreateRequestBody']
      }
    }
    responses: {
      /** @description Successfully created organization. */
      201: {
        content: {
          'application/json': components['schemas']['OrganizationRead']
        }
      }
    }
  }
  /** Update an organization info */
  updateOrganization: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['OrganizationUpdateRequestBody']
      }
    }
    responses: {
      /** @description Successfully updated organization info. */
      200: {
        content: {
          'application/json': components['schemas']['OrganizationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Delete an organization */
  deleteOrganization: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['OrganizationIdRequestBody']
      }
    }
    responses: {
      /** @description Successfully deleted organization. */
      204: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** List organizations by a given user id. The function also supports searching by keyword and pagination. */
  listOrganizationsByUser: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ListOrganizationsByUserRequestBody']
      }
    }
    responses: {
      /** @description Successfully retrieved organizations by given user id. */
      200: {
        content: {
          'application/json': components['schemas']['OrganizationReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** Provides the Airbyte deployment metadata. */
  getDeploymentMetadata: {
    responses: {
      /** @description The Airbyte deployment metadata. */
      200: {
        content: {
          'application/json': components['schemas']['DeploymentMetadataRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /**
   * Returns all Applications for a User.
   * @description List Applications for a User.
   */
  listApplications: {
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ApplicationReadList']
        }
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Deletes an Application.
   * @description Deletes an Application.
   */
  deleteApplication: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ApplicationIdRequestBody']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: never
      }
      404: components['responses']['NotFoundResponse']
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Creates a new Application.
   * @description Creates a new Application.
   */
  createApplication: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ApplicationCreate']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ApplicationRead']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /**
   * Grant an Access Token for an Application.
   * @description Takes the client_id and client_secret for an application and returns an Access Token.
   */
  applicationTokenRequest: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ApplicationTokenRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['AccessToken']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get all scoped configurations with a given key */
  getScopedConfigurationsList: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ScopedConfigurationListRequestBody']
      }
    }
    responses: {
      /** @description An array of scoped configurations */
      200: {
        content: {
          'application/json': components['schemas']['ScopedConfigurationListResponse']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get related configurations for a given scope */
  getScopedConfigurationContext: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ScopedConfigurationContextRequestBody']
      }
    }
    responses: {
      /** @description An array of scoped configurations */
      200: {
        content: {
          'application/json': components['schemas']['ScopedConfigurationContextResponse']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create a new scoped configuration */
  createScopedConfiguration: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ScopedConfigurationCreateRequestBody']
      }
    }
    responses: {
      /** @description Newly created scoped configuration */
      200: {
        content: {
          'application/json': components['schemas']['ScopedConfigurationCreateResponse']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Get a scoped configuration by ID */
  getScopedConfigurationById: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ScopedConfigurationReadRequestBody']
      }
    }
    responses: {
      /** @description A Scoped configuration */
      200: {
        content: {
          'application/json': components['schemas']['ScopedConfigurationReadResponse']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Update a scoped configuration by ID */
  updateScopedConfiguration: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ScopedConfigurationUpdateRequestBody']
      }
    }
    responses: {
      /** @description Updated scoped configuration object */
      200: {
        content: {
          'application/json': components['schemas']['ScopedConfigurationUpdateResponse']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Delete a scoped configuration by ID */
  deleteScopedConfiguration: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['ScopedConfigurationDeleteRequestBody']
      }
    }
    responses: {
      /** @description Deleted scoped configuration object */
      200: {
        content: {
          'application/json': components['schemas']['ScopedConfigurationDeleteResponse']
        }
      }
      422: components['responses']['InvalidInputResponse']
    }
  }
  /** Create a user invitation */
  createUserInvitation: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['UserInvitationCreateRequestBody']
      }
    }
    responses: {
      /** @description Successfully processed user invitation create request. */
      201: {
        content: {
          'application/json': components['schemas']['UserInvitationCreateResponse']
        }
      }
    }
  }
  /** Get a user invitation by its unique code (not primary key ID) */
  getUserInvitation: {
    parameters: {
      path: {
        /** @description The invite code of the user invitation to get. */
        inviteCode: string
      }
    }
    responses: {
      /** @description Successfully retrieved user invitation. */
      200: {
        content: {
          'application/json': components['schemas']['UserInvitationRead']
        }
      }
      404: components['responses']['NotFoundResponse']
    }
  }
  /** List pending invitations */
  listPendingInvitations: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['UserInvitationListRequestBody']
      }
    }
    responses: {
      /** @description A list of pending user invitations, or an empty list if no invitations are found. */
      200: {
        content: {
          'application/json': components['schemas']['UserInvitationRead'][]
        }
      }
    }
  }
  /** Accept a user invitation */
  acceptUserInvitation: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['InviteCodeRequestBody']
      }
    }
    responses: {
      /** @description Successfully accepted user invitation. */
      201: {
        content: {
          'application/json': components['schemas']['UserInvitationRead']
        }
      }
    }
  }
  /** Decline a user invitation */
  declineUserInvitation: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['InviteCodeRequestBody']
      }
    }
    responses: {
      /** @description Successfully declined user invitation. */
      201: {
        content: {
          'application/json': components['schemas']['UserInvitationRead']
        }
      }
    }
  }
  /** Cancel a user invitation */
  cancelUserInvitation: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['InviteCodeRequestBody']
      }
    }
    responses: {
      /** @description Successfully cancelled user invitation. */
      201: {
        content: {
          'application/json': components['schemas']['UserInvitationRead']
        }
      }
    }
  }
  /** Root path, currently returns a redirect to the documentation */
  getDocumentation: {
    responses: {
      /** @description Redirects to documentation */
      200: {
        content: {
          'text/html': unknown
        }
      }
    }
  }
  /** Health Check */
  publicGetHealthCheck: {
    responses: {
      /** @description Successful operation */
      200: {
        content: never
      }
    }
  }
  /** List Jobs by sync type */
  listJobs: {
    parameters: {
      query?: {
        /** @description Filter the Jobs by connectionId. */
        connectionId?: string
        /** @description Set the limit on the number of Jobs returned. The default is 20 Jobs. */
        limit?: number
        /** @description Set the offset to start at when returning Jobs. The default is 0. */
        offset?: number
        /** @description Filter the Jobs by jobType. */
        jobType?: components['schemas']['JobTypeEnum']
        /** @description The UUIDs of the workspaces you wish to list jobs for. Empty list will retrieve all allowed workspaces. */
        workspaceIds?: string[]
        /** @description The Job status you want to filter by */
        status?: components['schemas']['JobStatusEnum']
        /**
         * @description The start date to filter by
         * @example 2023-06-22T16:15:00Z
         */
        createdAtStart?: string
        /**
         * @description The end date to filter by
         * @example 2023-06-22T16:15:00Z
         */
        createdAtEnd?: string
        /**
         * @description The start date to filter by
         * @example 2023-06-22T16:15:00Z
         */
        updatedAtStart?: string
        /**
         * @description The end date to filter by
         * @example 2023-06-22T16:15:00Z
         */
        updatedAtEnd?: string
        /**
         * @description The field and method to use for ordering
         * @example updatedAt|DESC
         */
        orderBy?: string
      }
    }
    responses: {
      /** @description List all the Jobs by connectionId. */
      200: {
        content: {
          'application/json': components['schemas']['JobsResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /** Trigger a sync or reset job of a connection */
  publicCreateJob: {
    requestBody: {
      content: {
        'application/json': components['schemas']['JobCreateRequest']
      }
    }
    responses: {
      /** @description Kicks off a new Job based on the JobType. The connectionId is the resource that Job will be run for. */
      200: {
        content: {
          'application/json': components['schemas']['JobResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /** Get Job status and details */
  getJob: {
    parameters: {
      path: {
        jobId: number
      }
    }
    responses: {
      /** @description Get a Job by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['JobResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Cancel a running Job */
  publicCancelJob: {
    parameters: {
      path: {
        jobId: number
      }
    }
    responses: {
      /** @description Cancel a Job. */
      200: {
        content: {
          'application/json': components['schemas']['JobResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** List sources */
  listSources: {
    parameters: {
      query?: {
        /**
         * @description The UUIDs of the workspaces you wish to list sources for. Empty list will retrieve all allowed workspaces.
         * @example df08f6b0-b364-4cc1-9b3f-96f5d2fccfb2,b0796797-de23-4fc7-a5e2-7e131314718c
         */
        workspaceIds?: string[]
        /** @description Include deleted sources in the returned results. */
        includeDeleted?: boolean
        /** @description Set the limit on the number of sources returned. The default is 20. */
        limit?: number
        /** @description Set the offset to start at when returning sources. The default is 0 */
        offset?: number
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourcesResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /**
   * Create a source
   * @description Creates a source given a name, workspace id, and a json blob containing the configuration for the source.
   */
  publicCreateSource: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['SourceCreateRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['SourceResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /** Get Source details */
  publicGetSource: {
    parameters: {
      path: {
        sourceId: string
      }
    }
    responses: {
      /** @description Get a Source by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['SourceResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Update a Source and fully overwrite it */
  putSource: {
    parameters: {
      path: {
        sourceId: string
      }
    }
    requestBody?: {
      content: {
        'application/json': components['schemas']['SourcePutRequest']
      }
    }
    responses: {
      /** @description Update a source and fully overwrite it */
      200: {
        content: {
          'application/json': components['schemas']['SourceResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Delete a Source */
  publicDeleteSource: {
    parameters: {
      path: {
        sourceId: string
      }
    }
    responses: {
      /** @description The resource was deleted successfully */
      204: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Update a Source */
  patchSource: {
    parameters: {
      path: {
        sourceId: string
      }
    }
    requestBody?: {
      content: {
        'application/json': components['schemas']['SourcePatchRequest']
      }
    }
    responses: {
      /** @description Update a Source */
      200: {
        content: {
          'application/json': components['schemas']['SourceResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** List destinations */
  listDestinations: {
    parameters: {
      query?: {
        /** @description The UUIDs of the workspaces you wish to list destinations for. Empty list will retrieve all allowed workspaces. */
        workspaceIds?: string[]
        /** @description Include deleted destinations in the returned results. */
        includeDeleted?: boolean
        /** @description Set the limit on the number of destinations returned. The default is 20. */
        limit?: number
        /** @description Set the offset to start at when returning destinations. The default is 0 */
        offset?: number
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationsResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /**
   * Create a destination
   * @description Creates a destination given a name, workspace id, and a json blob containing the configuration for the source.
   */
  publicCreateDestination: {
    requestBody?: {
      content: {
        'application/json': components['schemas']['DestinationCreateRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['DestinationResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Get Destination details */
  publicGetDestination: {
    parameters: {
      path: {
        destinationId: string
      }
    }
    responses: {
      /** @description Get a Destination by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['DestinationResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Update a Destination and fully overwrite it */
  putDestination: {
    parameters: {
      path: {
        destinationId: string
      }
    }
    requestBody?: {
      content: {
        'application/json': components['schemas']['DestinationPutRequest']
      }
    }
    responses: {
      /** @description Update a Destination and fully overwrite it */
      200: {
        content: {
          'application/json': components['schemas']['DestinationResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Delete a Destination */
  publicDeleteDestination: {
    parameters: {
      path: {
        destinationId: string
      }
    }
    responses: {
      /** @description The resource was deleted successfully */
      204: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Update a Destination */
  patchDestination: {
    parameters: {
      path: {
        destinationId: string
      }
    }
    requestBody?: {
      content: {
        'application/json': components['schemas']['DestinationPatchRequest']
      }
    }
    responses: {
      /** @description Update a Destination */
      200: {
        content: {
          'application/json': components['schemas']['DestinationResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /**
   * Receive OAuth callbacks
   * @description Redirected to by identity providers after authentication.
   */
  oauthCallback: {
    parameters: {
      query?: {
        /** @description Query parameters. Should contain state and code. */
        queryParams?: {
          [key: string]: string
        }
      }
    }
    responses: {
      /** @description Redirect to the URL requested in the initiate call with the created secret ID. */
      302: {
        content: never
      }
    }
  }
  /**
   * Initiate OAuth for a source
   * @description Given a source ID, workspace ID, and redirect URL, initiates OAuth for the source.
   *
   * This returns a fully formed URL for performing user authentication against the relevant source identity provider (IdP). Once authentication has been completed, the IdP will redirect to an Airbyte endpoint which will save the access and refresh tokens off as a secret and return the secret ID to the redirect URL specified in the `secret_id` query string parameter.
   *
   * That secret ID can be used to create a source with credentials in place of actual tokens.
   */
  initiateOAuth: {
    requestBody: {
      content: {
        'application/json': components['schemas']['InitiateOauthRequest']
      }
    }
    responses: {
      200: components['responses']['InitiateOauthResponse']
      /** @description A field in the body has not been set appropriately. */
      400: {
        content: never
      }
      /** @description API key is invalid. */
      403: {
        content: never
      }
    }
  }
  /** List connections */
  listConnections: {
    parameters: {
      query?: {
        /** @description The UUIDs of the workspaces you wish to list connections for. Empty list will retrieve all allowed workspaces. */
        workspaceIds?: string[]
        /** @description Include deleted connections in the returned results. */
        includeDeleted?: boolean
        /** @description Set the limit on the number of Connections returned. The default is 20. */
        limit?: number
        /** @description Set the offset to start at when returning Connections. The default is 0 */
        offset?: number
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionsResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Create a connection */
  publicCreateConnection: {
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionCreateRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /** Get Connection details */
  publicGetConnection: {
    parameters: {
      path: {
        connectionId: string
      }
    }
    responses: {
      /** @description Get a Connection by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Delete a Connection */
  publicDeleteConnection: {
    parameters: {
      path: {
        connectionId: string
      }
    }
    responses: {
      /** @description The resource was deleted successfully */
      204: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Update Connection details */
  patchConnection: {
    parameters: {
      path: {
        connectionId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['ConnectionPatchRequest']
      }
    }
    responses: {
      /** @description Update a Connection by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['ConnectionResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Get stream properties */
  getStreamProperties: {
    parameters: {
      query: {
        /** @description ID of the source */
        sourceId: string
        /** @description ID of the destination */
        destinationId?: string
        /** @description If true pull the latest schema from the source, else pull from cache (default false) */
        ignoreCache?: boolean
      }
    }
    responses: {
      /** @description Get the available streams properties for a source/destination pair. */
      200: {
        content: {
          'application/json': components['schemas']['StreamPropertiesResponse']
        }
      }
      /** @description Required parameters are missing */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** List workspaces */
  publicListWorkspaces: {
    parameters: {
      query?: {
        /** @description The UUIDs of the workspaces you wish to fetch. Empty list will retrieve all allowed workspaces. */
        workspaceIds?: string[]
        /** @description Include deleted workspaces in the returned results. */
        includeDeleted?: boolean
        /** @description Set the limit on the number of workspaces returned. The default is 20. */
        limit?: number
        /** @description Set the offset to start at when returning workspaces. The default is 0 */
        offset?: number
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspacesResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Create a workspace */
  publicCreateWorkspace: {
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceCreateRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /** Get Workspace details */
  publicGetWorkspace: {
    parameters: {
      path: {
        workspaceId: string
      }
    }
    responses: {
      /** @description Get a Workspace by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Delete a Workspace */
  publicDeleteWorkspace: {
    parameters: {
      path: {
        workspaceId: string
      }
    }
    responses: {
      /** @description The resource was deleted successfully */
      204: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Update a workspace */
  publicUpdateWorkspace: {
    parameters: {
      path: {
        workspaceId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceUpdateRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['WorkspaceResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /**
   * Create OAuth override credentials for a workspace and source type.
   * @description Create/update a set of OAuth credentials to override the Airbyte-provided OAuth credentials used for source/destination OAuth.
   * In order to determine what the credential configuration needs to be, please see the connector specification of the relevant  source/destination.
   */
  createOrUpdateWorkspaceOAuthCredentials: {
    parameters: {
      path: {
        workspaceId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['WorkspaceOAuthCredentialsRequest']
      }
    }
    responses: {
      /** @description OAuth credential override was successful. */
      200: {
        content: never
      }
      /** @description A field in the body has not been set appropriately. */
      400: {
        content: never
      }
      /** @description API key is invalid. */
      403: {
        content: never
      }
    }
  }
  /** Get Permission details */
  publicGetPermission: {
    parameters: {
      path: {
        permissionId: string
      }
    }
    responses: {
      /** @description Get a Permission by the id in the path. */
      200: {
        content: {
          'application/json': components['schemas']['PermissionResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
      /** @description Data issue */
      422: {
        content: never
      }
    }
  }
  /** Delete a Permission */
  publicDeletePermission: {
    parameters: {
      path: {
        permissionId: string
      }
    }
    responses: {
      /** @description The resource was deleted successfully */
      204: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
      /** @description Data issue */
      422: {
        content: never
      }
    }
  }
  /** Update a permission */
  publicUpdatePermission: {
    parameters: {
      path: {
        permissionId: string
      }
    }
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionUpdateRequest']
      }
    }
    responses: {
      /** @description Successful updated */
      200: {
        content: {
          'application/json': components['schemas']['PermissionResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
      /** @description Data issue */
      422: {
        content: never
      }
    }
  }
  /** List Permissions by user id */
  publicListPermissionsByUserId: {
    parameters: {
      query?: {
        /** @description User Id in permission. */
        userId?: string
      }
    }
    responses: {
      /** @description List Permissions. */
      200: {
        content: {
          'application/json': components['schemas']['PermissionsResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
  /** Create a permission */
  publicCreatePermission: {
    requestBody: {
      content: {
        'application/json': components['schemas']['PermissionCreateRequest']
      }
    }
    responses: {
      /** @description Successful operation */
      200: {
        content: {
          'application/json': components['schemas']['PermissionResponse']
        }
      }
      /** @description Invalid data */
      400: {
        content: never
      }
      /** @description Not allowed */
      403: {
        content: never
      }
    }
  }
  /**
   * List users
   * @description Lists users based on provided filters. You can filter on either a list of IDs or a list of emails, but not both. If no filters provided we will list all users by default.
   */
  publicListUsers: {
    parameters: {
      query?: {
        /** @description List of user IDs to filter by */
        ids?: string[]
        /** @description List of user emails to filter by */
        emails?: string[]
        organizationId?: string
      }
    }
    responses: {
      /** @description List Users. */
      200: {
        content: {
          'application/json': components['schemas']['UsersResponse']
        }
      }
      /** @description Not allowed */
      403: {
        content: never
      }
      /** @description Not found */
      404: {
        content: never
      }
    }
  }
}

export interface oasTypes {
  components: components
  external: external
  operations: operations
  paths: paths
  webhooks: webhooks
}

export default oasTypes
